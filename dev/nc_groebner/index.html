<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-commutative Gröbner bases · KnuthBendix.jl</title><meta name="title" content="Non-commutative Gröbner bases · KnuthBendix.jl"/><meta property="og:title" content="Non-commutative Gröbner bases · KnuthBendix.jl"/><meta property="twitter:title" content="Non-commutative Gröbner bases · KnuthBendix.jl"/><meta name="description" content="Documentation for KnuthBendix.jl."/><meta property="og:description" content="Documentation for KnuthBendix.jl."/><meta property="twitter:description" content="Documentation for KnuthBendix.jl."/><meta property="og:url" content="https://kalmarek.github.io/KnuthBendix.jl/nc_groebner/"/><meta property="twitter:url" content="https://kalmarek.github.io/KnuthBendix.jl/nc_groebner/"/><link rel="canonical" href="https://kalmarek.github.io/KnuthBendix.jl/nc_groebner/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KnuthBendix.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory/">Monoids and the word problem</a></li><li><a class="tocitem" href="../knuthbendix_completion/">Confluence and the Knuth-Bendix completion</a></li></ul></li><li><span class="tocitem">Words and Alphabets</span><ul><li><a class="tocitem" href="../words/">Words</a></li><li><a class="tocitem" href="../alphabets/">Alphabets</a></li><li><a class="tocitem" href="../orders/">Orders</a></li></ul></li><li><span class="tocitem">Rewriting</span><ul><li><a class="tocitem" href="../rewriting/">On rewriting</a></li><li><a class="tocitem" href="../rewriting_system/">Rewriting System</a></li></ul></li><li><span class="tocitem">Knuth-Bendix completion</span><ul><li><a class="tocitem" href="../KB_implementations/">Implementations of Knuth-Bendix completion</a></li><li><a class="tocitem" href="../knuthbendix1/">Naive</a></li><li><a class="tocitem" href="../knuthbendix2/">Using a stack</a></li><li><a class="tocitem" href="../knuthbendix_idxA/">Using index automaton</a></li><li><a class="tocitem" href="../knuthbendix_pfxA/">Using prefix automaton</a></li></ul></li><li><span class="tocitem">Automata</span><ul><li><a class="tocitem" href="../automata/">Interface</a></li><li><a class="tocitem" href="../backtrack/">Backtrack searches</a></li><li><a class="tocitem" href="../index_automaton/">Index Automaton</a></li><li><a class="tocitem" href="../prefix_automaton/">Prefix Automaton</a></li></ul></li><li><a class="tocitem" href="../parsing_kbmag/">Parsing <code>kbmag</code> input files</a></li><li><span class="tocitem">Applications</span><ul><li class="is-active"><a class="tocitem" href>Non-commutative Gröbner bases</a><ul class="internal"><li><a class="tocitem" href="#Physics-inspired-example"><span>Physics inspired example</span></a></li></ul></li><li><a class="tocitem" href="../builtin_examples/">Example rewriting systems</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Applications</a></li><li class="is-active"><a href>Non-commutative Gröbner bases</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Non-commutative Gröbner bases</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl/blob/master/docs/src/nc_groebner.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Non-commutative-Gröbner-bases"><a class="docs-heading-anchor" href="#Non-commutative-Gröbner-bases">Non-commutative Gröbner bases</a><a id="Non-commutative-Gröbner-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Non-commutative-Gröbner-bases" title="Permalink"></a></h1><p>Here is a small example how this package can be useful outside of the realm of the theory of finitely presented monoids. Finding a normal form for polynomial algebras</p><p class="math-container">\[\mathbb{K}\langle x_1, \ldots, x_n\rangle\big/
(f_1(x_1,\ldots, x_n), \ldots, f_k(x_1, \ldots, x_n))\]</p><p>in non-commutative variables modulo certain polynomial equations is a standard problem that can be solved via the computation the non-commutative Gröbner basis. For an example of such approach see <a href="https://gap-packages.github.io/gbnp/doc/chap0.html">GAP package <code>gbnp</code></a>. It is curious that the majority (but not all!) of the examples listed in <a href="https://gap-packages.github.io/gbnp/doc/chapA.html">Appendix A</a> are generated by a set of equations which equate one monomial to some other, i.e. all <span>$f_i(x_1, \ldots, x_n)$</span> are of the form <span>$m_1 = k\cdot m_2$</span> where <span>$m_i$</span> are simply monomials in variables <span>$x_1, \ldots, x_n$</span> and <span>$k \in \mathbb{K}$</span>.</p><p>To compute normal forms in such (associative) algebras it is enough to rephrase the problem as a problem of finding the normal form in <strong>monoid algebra</strong>, with monoid generated by <span>$x_1, \ldots, x_n$</span> possibly extended by zero and a finite set of units from <span>$\mathbb{K}$</span>.</p><h2 id="Physics-inspired-example"><a class="docs-heading-anchor" href="#Physics-inspired-example">Physics inspired example</a><a id="Physics-inspired-example-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-inspired-example" title="Permalink"></a></h2><p>The example is derived from a <a href="https://github.com/blegat/CondensedMatterSOS.jl/blob/19bf2ebc4923fffba1e9263022b836c429ea9c7d/src/types.jl#L107-L171">description of relations</a> between spin variables. In short we have three sets of variables <span>$(\sigma^x)_i$</span>, <span>$(\sigma^y)_i$</span> and <span>$(\sigma^z)_i$</span> for <span>$i \in \{1, \ldots, L\}$</span>. These variables satisfy the following relations (here <span>$\mathbf{i}$</span> denotes the complex unit):</p><p class="math-container">\[\begin{aligned}
(\sigma^a)_i^2 &amp; = 1 &amp;i=1,\ldots,L,\; a\in \{x,y,z\},\\
(\sigma^x)_i (\sigma^y)_i &amp;= \mathbf{i}(\sigma^z)_i &amp; i=1,\ldots,L,\\
(\sigma^y)_i (\sigma^z)_i &amp;= \mathbf{i}(\sigma^x)_i &amp; i=1,\ldots,L,\\
(\sigma^z)_i (\sigma^x)_i &amp;= \mathbf{i}(\sigma^y)_i &amp; i=1,\ldots,L,\\
(\sigma^a)_i (\sigma^b)_j &amp;= (\sigma^b)_j (\sigma^a)_i &amp; 1 \leq i\neq j \leq L,\; a\in \{x,y,z\}.
\end{aligned}\]</p><p>Moreover we require anticommutativity of <span>$(\sigma^a)_i$</span> and <span>$(\sigma^b)_i$</span>, i.e. if <span>$(\sigma^a)_i (\sigma^b)_i = \mathbf{i}(\sigma^c)_i$</span>, then <span>$(\sigma^b)_i (\sigma^a)_i = -\mathbf{i}(\sigma^c)_i$</span>, but as we shall see, this already follows from the the rules.</p><p>If we treat <span>$\mathbf{i}$</span> as an additional variable commuting with every <span>$(\sigma^a)_i$</span>, then all of these rules equate one monomial to another and the computation of the normal form is therefore suitable for Knuth-Bendix completion! Let&#39;s have a look how one could implement this.</p><h3 id="The-alphabet"><a class="docs-heading-anchor" href="#The-alphabet">The alphabet</a><a id="The-alphabet-1"></a><a class="docs-heading-anchor-permalink" href="#The-alphabet" title="Permalink"></a></h3><p>Let us begin with an alphabet:</p><pre><code class="language-julia-repl hljs">julia&gt; L = 4
4

julia&gt; subscript = [&quot;₁&quot;, &quot;₂&quot;,&quot;₃&quot;,&quot;₄&quot;,&quot;₅&quot;,&quot;₆&quot;,&quot;₇&quot;,&quot;₈&quot;,&quot;₉&quot;,&quot;₀&quot;];

julia&gt; Sσˣ = [Symbol(:σˣ, subscript[i]) for i in 1:L]
4-element Vector{Symbol}:
 :σˣ₁
 :σˣ₂
 :σˣ₃
 :σˣ₄

julia&gt; Sσʸ = [Symbol(:σʸ, subscript[i]) for i in 1:L];

julia&gt; Sσᶻ = [Symbol(:σᶻ, subscript[i]) for i in 1:L];

julia&gt; SI = Symbol(:I); # the complex unit

julia&gt; letters = [SI; Sσˣ; Sσʸ; Sσᶻ];

julia&gt; A = Alphabet(letters, [0; 2:length(letters)])
Alphabet of Symbol
  1. I
  2. σˣ₁  (self-inverse)
  3. σˣ₂  (self-inverse)
  4. σˣ₃  (self-inverse)
  5. σˣ₄  (self-inverse)
  6. σʸ₁  (self-inverse)
  7. σʸ₂  (self-inverse)
  8. σʸ₃  (self-inverse)
  9. σʸ₄  (self-inverse)
 10. σᶻ₁  (self-inverse)
 11. σᶻ₂  (self-inverse)
 12. σᶻ₃  (self-inverse)
 13. σᶻ₄  (self-inverse)
</code></pre><p>Now let&#39;s define words with just those letters, so that we can use them as generators in the free monoid over <code>A</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; I = Word([A[SI]])
Word{UInt16}: 1

julia&gt; σˣ = [Word([A[s]]) for s in Sσˣ];

julia&gt; σʸ = [Word([A[s]]) for s in Sσʸ];

julia&gt; σᶻ = [Word([A[s]]) for s in Sσᶻ];
</code></pre><p>Note that <code>I</code> has no inverse among letters while all other are self-inverse.</p><h3 id="Rewriting-System"><a class="docs-heading-anchor" href="#Rewriting-System">Rewriting System</a><a id="Rewriting-System-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriting-System" title="Permalink"></a></h3><p>Let us define our relations now</p><pre><code class="language-julia-repl hljs">julia&gt; complex_unit = [(I^4, one(I))]
1-element Vector{Tuple{Word{UInt16}, Word{UInt16}}}:
 (1·1·1·1, (id))

julia&gt; Σ = [σˣ, σʸ, σᶻ];

julia&gt; # squares are taken care of by the inverses in the alphabet
       # squares = [(a*a, one(a)) for a in [σˣ;σʸ;σᶻ]]
       cyclic = [
            (σᵃ[i]*σᵇ[i], I*σᶜ[i]) for i in 1:L
                for (σᵃ, σᵇ, σᶜ) in (Σ, circshift(Σ,1), circshift(Σ,2))
            ]
12-element Vector{Tuple{Word{UInt16}, Word{UInt16}}}:
 (2·6, 1·10)
 (10·2, 1·6)
 (6·10, 1·2)
 (3·7, 1·11)
 (11·3, 1·7)
 (7·11, 1·3)
 (4·8, 1·12)
 (12·4, 1·8)
 (8·12, 1·4)
 (5·9, 1·13)
 (13·5, 1·9)
 (9·13, 1·5)

julia&gt; commutations = [
               (σᵃ[i]*σᵇ[j], σᵇ[j]*σᵃ[i]) for σᵃ in Σ for σᵇ in Σ
               for i in 1:L for j in 1:L if i ≠ j
           ];

julia&gt; append!(commutations,
        # I commutes with everything, since it comes from the field
            [(σ[i]*I, I*σ[i]) for σ in Σ for i in 1:L],
        )
120-element Vector{Tuple{Word{UInt16}, Word{UInt16}}}:
 (2·3, 3·2)
 (2·4, 4·2)
 (2·5, 5·2)
 (3·2, 2·3)
 (3·4, 4·3)
 (3·5, 5·3)
 (4·2, 2·4)
 (4·3, 3·4)
 (4·5, 5·4)
 (5·2, 2·5)
 ⋮
 (5·1, 1·5)
 (6·1, 1·6)
 (7·1, 1·7)
 (8·1, 1·8)
 (9·1, 1·9)
 (10·1, 1·10)
 (11·1, 1·11)
 (12·1, 1·12)
 (13·1, 1·13)

julia&gt; rws = RewritingSystem([complex_unit; cyclic; commutations], LenLex(A));

julia&gt; rwsC = knuthbendix(rws)
reduced, confluent rewriting system with 507 active rules.
rewriting ordering: LenLex: I &lt; σˣ₁ &lt; σˣ₂ &lt; σˣ₃ &lt; σˣ₄ &lt; σʸ₁ &lt; σʸ₂ &lt; σʸ₃ &lt; σʸ₄ &lt; σᶻ₁ &lt; σᶻ₂ &lt; σᶻ₃ &lt; σᶻ₄
┌──────┬──────────────────────────────────┬──────────────────────────────────┐
│ Rule │                              lhs │ rhs                              │
├──────┼──────────────────────────────────┼──────────────────────────────────┤
│    1 │                            σˣ₁*I │ I*σˣ₁                            │
│    2 │                            σˣ₁^2 │ (id)                             │
│    3 │                          σˣ₁*σʸ₁ │ I*σᶻ₁                            │
│    4 │                            σˣ₂*I │ I*σˣ₂                            │
│    5 │                          σˣ₂*σˣ₁ │ σˣ₁*σˣ₂                          │
│    6 │                            σˣ₂^2 │ (id)                             │
│    7 │                          σˣ₂*σʸ₂ │ I*σᶻ₂                            │
│    8 │                            σˣ₃*I │ I*σˣ₃                            │
│    9 │                          σˣ₃*σˣ₁ │ σˣ₁*σˣ₃                          │
│   10 │                          σˣ₃*σˣ₂ │ σˣ₂*σˣ₃                          │
│   11 │                            σˣ₃^2 │ (id)                             │
│   12 │                          σˣ₃*σʸ₃ │ I*σᶻ₃                            │
│   13 │                            σˣ₄*I │ I*σˣ₄                            │
│  ⋮   │                ⋮                 │                ⋮                 │
└──────┴──────────────────────────────────┴──────────────────────────────────┘
                                                              494 rows omitted
</code></pre><p>Previously we stated that the anticommutativity should hold, i.e. if</p><p class="math-container">\[(\sigma^a)_i (\sigma^b)_i (\sigma^c)_i = \mathbf{i}\quad \text{then} \quad
(\sigma^b)_i (\sigma^a)_i (\sigma^c)_i = -\mathbf{i} = \mathbf{i}^3.\]</p><p>Let us check this now.</p><pre><code class="language-julia-repl hljs">julia&gt; KnuthBendix.rewrite(σʸ[1]*σˣ[1], rwsC)
Word{UInt16}: 6·2

julia&gt; KnuthBendix.rewrite(I^3*σᶻ[1], rwsC)
Word{UInt16}: 6·2
</code></pre><p>Indeed, rewriting brings both of the words to the same form, so they must represent the same element in the monoid.</p><h3 id="Weighting-the-letters"><a class="docs-heading-anchor" href="#Weighting-the-letters">Weighting the letters</a><a id="Weighting-the-letters-1"></a><a class="docs-heading-anchor-permalink" href="#Weighting-the-letters" title="Permalink"></a></h3><p>If we want to force normalforms to begin with <code>I</code> (if a word with such presentation represents the given monomial) we could use <a href="../orders/#KnuthBendix.WeightedLex"><code>WeightedLex</code></a> ordering, weighting other letters disproportionally higher than <code>I</code>, e.g.</p><pre><code class="language-julia-repl hljs">julia&gt; wLA = WeightedLex(A, weights = [1; [10 for _ in 2:length(A)]])
WeightedLex: I(1) &lt; σˣ₁(10) &lt; σˣ₂(10) &lt; σˣ₃(10) &lt; σˣ₄(10) &lt; σʸ₁(10) &lt; σʸ₂(10) &lt; σʸ₃(10) &lt; σʸ₄(10) &lt; σᶻ₁(10) &lt; σᶻ₂(10) &lt; σᶻ₃(10) &lt; σᶻ₄(10)

julia&gt; rws2 = RewritingSystem([complex_unit; cyclic; commutations], wLA);

julia&gt; rwsC2 = knuthbendix(rws2)
reduced, confluent rewriting system with 263 active rules.
rewriting ordering: WeightedLex: I(1) &lt; σˣ₁(10) &lt; σˣ₂(10) &lt; σˣ₃(10) &lt; σˣ₄(10) &lt; σʸ₁(10) &lt; σʸ₂(10) &lt; σʸ₃(10) &lt; σʸ₄(10) &lt; σᶻ₁(10) &lt; σᶻ₂(10) &lt; σᶻ₃(10) &lt; σᶻ₄(10)
┌──────┬──────────────────────────────────┬──────────────────────────────────┐
│ Rule │                              lhs │ rhs                              │
├──────┼──────────────────────────────────┼──────────────────────────────────┤
│    1 │                              I^4 │ (id)                             │
│    2 │                            σˣ₁*I │ I*σˣ₁                            │
│    3 │                            σˣ₂*I │ I*σˣ₂                            │
│    4 │                            σˣ₃*I │ I*σˣ₃                            │
│    5 │                            σˣ₄*I │ I*σˣ₄                            │
│    6 │                            σʸ₁*I │ I*σʸ₁                            │
│    7 │                            σʸ₂*I │ I*σʸ₂                            │
│    8 │                            σʸ₃*I │ I*σʸ₃                            │
│    9 │                            σʸ₄*I │ I*σʸ₄                            │
│   10 │                            σᶻ₁*I │ I*σᶻ₁                            │
│   11 │                            σᶻ₂*I │ I*σᶻ₂                            │
│   12 │                            σᶻ₃*I │ I*σᶻ₃                            │
│   13 │                            σᶻ₄*I │ I*σᶻ₄                            │
│  ⋮   │                ⋮                 │                ⋮                 │
└──────┴──────────────────────────────────┴──────────────────────────────────┘
                                                              250 rows omitted


julia&gt; KnuthBendix.rewrite(σʸ[1]*σˣ[1], rwsC2)
Word{UInt16}: 1·1·1·10

julia&gt; KnuthBendix.print_repr(stdout, ans, A)
I^3*σᶻ₁
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../parsing_kbmag/">« Parsing <code>kbmag</code> input files</a><a class="docs-footer-nextpage" href="../builtin_examples/">Example rewriting systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 20 November 2024 18:22">Wednesday 20 November 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Monoids and the word problem · KnuthBendix.jl</title><meta name="title" content="Monoids and the word problem · KnuthBendix.jl"/><meta property="og:title" content="Monoids and the word problem · KnuthBendix.jl"/><meta property="twitter:title" content="Monoids and the word problem · KnuthBendix.jl"/><meta name="description" content="Documentation for KnuthBendix.jl."/><meta property="og:description" content="Documentation for KnuthBendix.jl."/><meta property="twitter:description" content="Documentation for KnuthBendix.jl."/><meta property="og:url" content="https://kalmarek.github.io/KnuthBendix.jl/theory/"/><meta property="twitter:url" content="https://kalmarek.github.io/KnuthBendix.jl/theory/"/><link rel="canonical" href="https://kalmarek.github.io/KnuthBendix.jl/theory/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KnuthBendix.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li class="is-active"><a class="tocitem" href>Monoids and the word problem</a><ul class="internal"><li><a class="tocitem" href="#Monoids-and-their-presentations"><span>Monoids and their presentations</span></a></li><li><a class="tocitem" href="#Word-Problem"><span>Word Problem</span></a></li><li><a class="tocitem" href="#Normal-forms-and-rewriting-systems"><span>Normal forms and rewriting systems</span></a></li></ul></li><li><a class="tocitem" href="../knuthbendix_completion/">Confluence and the Knuth-Bendix completion</a></li></ul></li><li><span class="tocitem">Words and Alphabets</span><ul><li><a class="tocitem" href="../words/">Words</a></li><li><a class="tocitem" href="../alphabets/">Alphabets</a></li><li><a class="tocitem" href="../orders/">Orders</a></li></ul></li><li><span class="tocitem">Rewriting</span><ul><li><a class="tocitem" href="../rewriting/">On rewriting</a></li><li><a class="tocitem" href="../rewriting_system/">Rewriting System</a></li></ul></li><li><span class="tocitem">Knuth-Bendix completion</span><ul><li><a class="tocitem" href="../KB_implementations/">Implementations of Knuth-Bendix completion</a></li><li><a class="tocitem" href="../knuthbendix1/">Naive</a></li><li><a class="tocitem" href="../knuthbendix2/">Using a stack</a></li><li><a class="tocitem" href="../knuthbendix_idxA/">Using index automaton</a></li></ul></li><li><span class="tocitem">Automata</span><ul><li><a class="tocitem" href="../automata/">Interface</a></li><li><a class="tocitem" href="../backtrack/">Backtrack searches</a></li><li><a class="tocitem" href="../index_automaton/">-</a></li><li><a class="tocitem" href="../prefix_automaton/">-</a></li></ul></li><li><a class="tocitem" href="../parsing_kbmag/">Parsing <code>kbmag</code> input files</a></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../nc_groebner/">Non-commutative Gröbner bases</a></li><li><a class="tocitem" href="../builtin_examples/">Example rewriting systems</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Theory</a></li><li class="is-active"><a href>Monoids and the word problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Monoids and the word problem</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl/blob/master/docs/src/theory.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Monoids-and-the-word-problem"><a class="docs-heading-anchor" href="#Monoids-and-the-word-problem">Monoids and the word problem</a><a id="Monoids-and-the-word-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Monoids-and-the-word-problem" title="Permalink"></a></h1><p>This package implements Knuth-Bendix completion of a rewriting system derived from a presentation of a monoid.</p><h2 id="Monoids-and-their-presentations"><a class="docs-heading-anchor" href="#Monoids-and-their-presentations">Monoids and their presentations</a><a id="Monoids-and-their-presentations-1"></a><a class="docs-heading-anchor-permalink" href="#Monoids-and-their-presentations" title="Permalink"></a></h2><p>In general one starts with an alphabet <span>$\mathcal{A}$</span>, creates a free monoid <span>$\mathcal{A}^*$</span> (the set of all words over the alphabet, with concatenation) and then forms a quotient of <span>$\mathcal{A}^*$</span> by a <em>congruence</em> <span>$R ⊂ \mathcal{A}^*\times \mathcal{A}^*$</span> Recall that a <em>congruence</em> on a monoid is an equivalence relation whose equivalence classes are preserved by monoid multiplication. Under this assumption the quotient inherits the structure of a <em>quotient monoid</em> <span>$Q = \mathcal{A}^*/R$</span>.</p><p>In the case of a congruence on a group, the equivalence class of the (group) identity <span>$[1]$</span> is a normal subgroup, and each equivalence class of <span>$R$</span> is a shift of it (these are cosets). As it is well known, the quotient <span>$Q$</span> inherits the group structure. In monoids, however, congruences are not necessarily determined by <span>$[1]$</span> only.</p><p>One usually does not have the full set of equivalence classes at their disposal, but only a small set of pairs in relation that <em>generate</em> the congruence. This is traditionally written as a <em>monoid presentation</em> <span>$\langle \mathcal{A} \mid R \rangle$</span>, e.g.: <span>$M = \langle x, X, y \mid x\cdot X = X\cdot x =\varepsilon, xy = yx \rangle.$</span> Here by <span>$x\cdot X = \varepsilon$</span> we mean that <span>$R$</span> contains the pair <span>$(x\cdot X, \varepsilon)$</span> (the latter denoting the trivial element of <span>$\mathcal{A}^*$</span>, i.e. the empty word) and <span>$R$</span> is the smallest congruence on <span>$\mathcal{A}^*$</span> which contains the pairs indicated by the equations.</p><h2 id="Word-Problem"><a class="docs-heading-anchor" href="#Word-Problem">Word Problem</a><a id="Word-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Word-Problem" title="Permalink"></a></h2><p>One of the most natural problems in this setting is to determine when do two words in <span>$\mathcal{A}^*$</span> represent the same element of <span>$M$</span>, i.e. belong to the same congruence class of <span>$R$</span>. This is the famous (unsolvable in general) word problem:</p><div class="admonition is-info"><header class="admonition-header">Word Problem</header><div class="admonition-body"><p>When do words <span>$v$</span> and <span>$w$</span> from <span>$\mathcal{A}^*$</span> represent the same element of <span>$M$</span>?</p></div></div><p>Is it unsolvable though? Here is a somehow trivial solution of the word problem using the axiom of choice:</p><div class="admonition is-success"><header class="admonition-header">Solution using AC</header><div class="admonition-body"><p>By the axiom of choice we could pick a distinguished element from every congruence class of <span>$R$</span>. Given <span>$v$</span> let <span>$[v] \subset \mathcal{A}^*$</span> denote its congruence class and <span>$v_0$</span> the corresponding distinguished element. Similarly we could find the element <span>$w_0 \in [w]$</span> in the congruence class of <span>$w$</span>. The words represent the same element if and only if <span>$v_0 = w_0$</span>.</p></div></div><p>The <em>unsolvability</em> of the Word Problem is rather caused by the very specific model of computations (i.e. Turing machine) rather than unsolvability in the sense of providing a solution using broadly accepted mathematics.</p><h2 id="Normal-forms-and-rewriting-systems"><a class="docs-heading-anchor" href="#Normal-forms-and-rewriting-systems">Normal forms and rewriting systems</a><a id="Normal-forms-and-rewriting-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-forms-and-rewriting-systems" title="Permalink"></a></h2><p>The choice of a distinguished element from each congruence class is sometimes referred to as the choice of a <em>normal form</em> (or <em>canonical form</em>) for <span>$R$</span>. If we could compute the normal form without referring to axiom of choice, we could solve the word problem.</p><p>A particular approach to normal forms is given by rewriting systems. To begin we need not only the set of pairs but also a <em>rewriting ordering</em> i.e. a bi-invariant well-ordering of <span>$\mathcal{A}^*$</span>. For the first reading you may think of ordering words by length and then by lexicographical order - it is a valid example of rewriting ordering. Such set of pairs and the order is called the rewriting system <span>$\mathcal{R}(R, &lt;)$</span>. One usually thinks in this context of element of <span>$R$</span> as rewriting equations <span>$p \to q$</span>, where <span>$p$</span> is always greater than <span>$q$</span> according to the order.</p><p>The process of rewriting then follows by finding in <span>$w = w_n$</span> any word <span>$p$</span> (as a subword) which is a left hand side of a rule <span>$p \to q \in \mathcal{R}$</span> and replacing it with <span>$q$</span> to obtain <span>$w_{n-1}$</span>. By the bi-invariance this process forms a decreasing sequence of words</p><p class="math-container">\[w=w_n &gt; w_{n-1} &gt; \cdots &gt; w_1 &gt; w_0\]</p><p>which must end after a finite number of rewrites (since <span>$&lt;$</span> is a well-ordering). Since applying rewriting rules doesn&#39;t change the congruence class <span>$w_0$</span> is congruent to the initial <span>$w$</span>. Then we could proclaim <span>$w_0$</span> to be the normal form for <span>$w$</span>. Unfortunately things are not so simple. The process of rewriting depends heavily on the order in which rules were used and on the positions where the matches of the left hand sides were found (note also that matches may overlap).</p><p>A rewriting system for which those choices don&#39;t matter is called <strong>confluent</strong>. Confluence of <span>$\mathcal{R}$</span> means that effectively <span>$w_0$</span> is the <strong>least element</strong> in the congruence class, which makes it a perfect choice for normal form!</p><p>The main purpose of the Knuth-Bendix completion is to bring any rewriting system <span>$\mathcal{R}$</span> to confluence (see the next chapter). In other words the Knuth-Bendix completion transforms the initial set of pairs generating congruence <span>$R$</span> (and an order <span>$&lt;$</span> on <span>$\mathcal{A}^*$</span>) into a rewriting system <span>$\mathcal{R}$</span> that computes the normal form in a constructive, deterministic fashion.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../knuthbendix_completion/">Confluence and the Knuth-Bendix completion »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Monday 22 July 2024 11:42">Monday 22 July 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>On rewriting · KnuthBendix.jl</title><meta name="title" content="On rewriting · KnuthBendix.jl"/><meta property="og:title" content="On rewriting · KnuthBendix.jl"/><meta property="twitter:title" content="On rewriting · KnuthBendix.jl"/><meta name="description" content="Documentation for KnuthBendix.jl."/><meta property="og:description" content="Documentation for KnuthBendix.jl."/><meta property="twitter:description" content="Documentation for KnuthBendix.jl."/><meta property="og:url" content="https://kalmarek.github.io/KnuthBendix.jl/rewriting/"/><meta property="twitter:url" content="https://kalmarek.github.io/KnuthBendix.jl/rewriting/"/><link rel="canonical" href="https://kalmarek.github.io/KnuthBendix.jl/rewriting/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KnuthBendix.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory/">Monoids and the word problem</a></li><li><a class="tocitem" href="../knuthbendix_completion/">Confluence and the Knuth-Bendix completion</a></li></ul></li><li><span class="tocitem">Words and Alphabets</span><ul><li><a class="tocitem" href="../words/">Words</a></li><li><a class="tocitem" href="../alphabets/">Alphabets</a></li><li><a class="tocitem" href="../orders/">Orders</a></li></ul></li><li><span class="tocitem">Rewriting</span><ul><li class="is-active"><a class="tocitem" href>On rewriting</a><ul class="internal"><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li class="toplevel"><a class="tocitem" href="#Particular-implementations-of-rewriting."><span>Particular implementations of rewriting.</span></a></li><li><a class="tocitem" href="#Naive-rewriting"><span>Naive rewriting</span></a></li><li><a class="tocitem" href="#Index-automaton-rewriting"><span>Index automaton rewriting</span></a></li><li><a class="tocitem" href="#Prefix-automaton-rewriting"><span>Prefix automaton rewriting</span></a></li></ul></li><li><a class="tocitem" href="../rewriting_system/">Rewriting System</a></li></ul></li><li><span class="tocitem">Knuth-Bendix completion</span><ul><li><a class="tocitem" href="../KB_implementations/">Implementations of Knuth-Bendix completion</a></li><li><a class="tocitem" href="../knuthbendix1/">Naive</a></li><li><a class="tocitem" href="../knuthbendix2/">Using a stack</a></li><li><a class="tocitem" href="../knuthbendix_idxA/">Using index automaton</a></li><li><a class="tocitem" href="../knuthbendix_pfxA/">Using prefix automaton</a></li></ul></li><li><span class="tocitem">Automata</span><ul><li><a class="tocitem" href="../automata/">Interface</a></li><li><a class="tocitem" href="../backtrack/">Backtrack searches</a></li><li><a class="tocitem" href="../index_automaton/">Index Automaton</a></li><li><a class="tocitem" href="../prefix_automaton/">Prefix Automaton</a></li></ul></li><li><a class="tocitem" href="../parsing_kbmag/">Parsing <code>kbmag</code> input files</a></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../nc_groebner/">Non-commutative Gröbner bases</a></li><li><a class="tocitem" href="../builtin_examples/">Example rewriting systems</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rewriting</a></li><li class="is-active"><a href>On rewriting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>On rewriting</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl/blob/master/docs/src/rewriting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="On-rewriting"><a class="docs-heading-anchor" href="#On-rewriting">On rewriting</a><a id="On-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#On-rewriting" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="KnuthBendix.rewrite"><a class="docstring-binding" href="#KnuthBendix.rewrite"><code>KnuthBendix.rewrite</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rewrite(u::AbstractWord, rewriting)</code></pre><p>Rewrites word <code>u</code> using the <code>rewriting</code> object. The object must implement <code>rewrite!(v::AbstractWord, w::AbstractWord, rewriting)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alph = Alphabet([:a, :A, :b], [2,1,3])
Alphabet of Symbol
  1. a    (inverse of: A)
  2. A    (inverse of: a)
  3. b    (self-inverse)

julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; rule = KnuthBendix.Rule(a*b =&gt; a)
1·3 ⇒ 1

julia&gt; KnuthBendix.rewrite(a*b^2*A*b^3, rule) == a*A*b^3
true

julia&gt; KnuthBendix.rewrite(a*A*b^3, alph) == b
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/ed3c4980c7bf37951e4d233a9786cbdeed23fa75/src/rewriting.jl#L11-L36">source</a></section></details></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><p>Implementing rewriting procedure naively could easily lead to quadratic complexity due to unnecessary moves of parts of the rewritten word. The linear-complexity algorithm uses two stacks <code>v</code> and <code>w</code>:</p><ul><li><code>v</code> is initially empty (represents the trivial word), while</li><li><code>w</code> contains the content of <code>u</code> (the word to be rewritten with its first letter on its top).</li></ul><div class="admonition is-info" id="Rewriting-algorithm-9f033b8b7d189790"><header class="admonition-header">Rewriting algorithm<a class="admonition-anchor" href="#Rewriting-algorithm-9f033b8b7d189790" title="Permalink"></a></header><div class="admonition-body"><ol><li>we pop the first letter <code>l = popfirst!(w)</code> from <code>w</code>,</li><li>we push <code>l</code> to the end of <code>v</code>,</li><li>we determine a rewritng rule (if it exists) <code>lhs → rhs</code> with <code>v = v&#39;·lhs</code> (i.e. <code>lhs</code> is equal to a suffix of <code>v</code>), and we set<ul><li><code>v ← v&#39;</code> i.e. we remove the suffix fom <code>v</code>, and</li><li><code>w ← rhs·w</code> i.e. <code>rhs</code> is <em>prepended</em> to <code>w</code></li></ul></li><li>if no such rule exists we go back to 1.</li></ol><p>These four steps are repeated until <code>w</code> becomes empty.</p></div></div><p>In julia flavoured pseudocode the rewrite procedure looks as follows:</p><pre><code class="language-julia hljs">function rewrite!(v::AbstractWord, w::AbstractWord, rewriting; kwargs...)
    while !isone(w)
        push!(v, popfirst!(w))
        res = find_rule_with_suffix(rewriting, v)
        isnothing(res) &amp;&amp; continue # no rule matching was found
        (lhs, rhs) = res
        @assert v[end-length(lhs)+1:end] == lhs # i.e. v = v&#39;·lhs
        resize!(v, length(v)-length(lhs)) # v ← v&#39;
        prepend!(w, rhs) # w ← rhs·w
    end
    return v
end</code></pre><p>In practice our implementations in place of stacks use <a href="#KnuthBendix.RewritingBuffer"><code>RewritingBuffer</code></a> which consists of a pair of <a href="../words/#KnuthBendix.Words.BufferWord"><code>BufferWord</code>s</a> (a special implementation of the <code>AbstractWord</code> API).</p><h1 id="Particular-implementations-of-rewriting."><a class="docs-heading-anchor" href="#Particular-implementations-of-rewriting.">Particular implementations of rewriting.</a><a id="Particular-implementations-of-rewriting.-1"></a><a class="docs-heading-anchor-permalink" href="#Particular-implementations-of-rewriting." title="Permalink"></a></h1><p>Here are some examples of the internal rewriting function already defined:</p><article><details class="docstring" open="true"><summary id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Rule}"><a class="docstring-binding" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Rule}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, rule::Rule)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> by using a single rewriting <code>rule</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; rule = KnuthBendix.Rule(a*b =&gt; a)
1·3 ⇒ 1

julia&gt; v = one(a); KnuthBendix.rewrite!(v, a*b^2*A*b^3, rule);

julia&gt; v == a*A*b^3
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/ed3c4980c7bf37951e4d233a9786cbdeed23fa75/src/rewriting.jl#L94-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, Alphabet}"><a class="docstring-binding" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, Alphabet}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, A::Alphabet)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> by applying free reductions as defined by the inverses present in alphabet <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alph = Alphabet([:a, :A, :b], [2,1,3])
Alphabet of Symbol
  1. a    (inverse of: A)
  2. A    (inverse of: a)
  3. b    (self-inverse)

julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; v = one(a); KnuthBendix.rewrite!(v, a*b^2*A*b^3, alph);

julia&gt; v == b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/ed3c4980c7bf37951e4d233a9786cbdeed23fa75/src/rewriting.jl#L129-L149">source</a></section></details></article><hr/><p>Let a rewriting system <code>rws</code> is given, and let <code>lhsₖ → rhsₖ</code> denote its <code>k</code>-th rule. Let <code>ℒ = {lhsₖ}ₖ</code> denote the language of left-hand-sides of <code>rws</code> and let <code>N = Σₖ length(lhsₖ)</code> be the total length of <code>ℒ</code>.</p><h2 id="Naive-rewriting"><a class="docs-heading-anchor" href="#Naive-rewriting">Naive rewriting</a><a id="Naive-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-rewriting" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, RewritingSystem}"><a class="docstring-binding" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, RewritingSystem}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, rws::RewritingSystem)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> using rewriting rules of <code>rws</code>.</p><p>The naive rewriting with <a href="../rewriting_system/#KnuthBendix.RewritingSystem"><code>RewritingSystem</code></a></p><ol><li>moves one letter from the beginning of <code>w</code> to the end of <code>v</code></li><li>checks every rule <code>lhs → rhs</code> in <code>rws</code> until <code>v</code> contains <code>lhs</code> as a suffix,</li><li>if found, the suffix is removed from <code>v</code> and <code>rhs</code> is prepended to <code>w</code>.</li></ol><p>Those steps repeat until <code>w</code> is empty.</p><p>The complexity of this rewriting is <code>Ω(length(w) · N)</code>, where <code>N</code> is the total size of left hand sides of the rewriting rules of <code>rws</code>.</p><p>See procedure <code>REWRITE_FROM_LEFT</code> from <strong>Section 2.4</strong><sup class="footnote-reference"><a id="citeref-Sims1994" href="#footnote-Sims1994" class="footnote-ref">[Sims1994]</a><span class="footnote-preview" id="fn-Sims1994"></span></sup>, p. 66.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/ed3c4980c7bf37951e4d233a9786cbdeed23fa75/src/rewriting.jl#L173-L193">source</a></section></details></article><p>The naive rewriting with a rewriting system is therefore in the worst case <strong>proportional</strong> to the total size of the whole <code>rws</code> which makes it a very inefficient rewriting strategy.</p><h2 id="Index-automaton-rewriting"><a class="docs-heading-anchor" href="#Index-automaton-rewriting">Index automaton rewriting</a><a id="Index-automaton-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Index-automaton-rewriting" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Automata.IndexAutomaton}"><a class="docstring-binding" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Automata.IndexAutomaton}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, idxA::Automata.IndexAutomaton)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> using index automaton <code>idxA</code>.</p><p>Rewriting with an <a href="../index_automaton/#KnuthBendix.Automata.IndexAutomaton"><code>IndexAutomaton</code></a> traces (i.e. follows) the path in the automaton determined by <code>w</code> (since the automaton is deterministic there is only one such path). Whenever a terminal (i.e. accepting) state is encountered</p><ol><li>its corresponding rule <code>lhs → rhs</code> is retrived,</li><li>the appropriate suffix of <code>v</code> (equal to <code>lhs</code>) is removed, and</li><li><code>rhs</code> is prepended to <code>w</code>.</li></ol><p>Tracing continues from the first letter of the newly prepended word.</p><p>To continue tracing <code>w</code> through the automaton we need to backtrack on our path in the automaton and for this <code>rewrite</code> maintains a vector of visited states of <code>idxA</code> (the history of visited states of <code>idxA</code>). Whenever a suffix is removed from <code>v</code>, the path is rewinded (i.e. shortened) to the appropriate length and the next letter of <code>w</code> is traced from the last state on the path. This maintains the property that signature of the path is equal to <code>v</code> at all times.</p><p>Once index automaton is build the complexity of this rewriting is <code>Ω(length(w))</code> which is the optimal rewriting strategy.</p><p>See procedure <code>INDEX_REWRITE</code> from <strong>Section 3.5</strong><sup class="footnote-reference"><a id="citeref-Sims1994" href="#footnote-Sims1994" class="footnote-ref">[Sims1994]</a><span class="footnote-preview" id="fn-Sims1994"></span></sup>, p. 113.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/ed3c4980c7bf37951e4d233a9786cbdeed23fa75/src/rewriting.jl#L216-L245">source</a></section></details></article><p>In practice the complexity of building and maintaining <code>idxA</code> synchronized with <code>ℒ</code> overwhelms gains made in rewriting (to construct <code>idxA</code> one need to fully <em>reduce</em> <code>rws</code> first which is a very costly operation).</p><h2 id="Prefix-automaton-rewriting"><a class="docs-heading-anchor" href="#Prefix-automaton-rewriting">Prefix automaton rewriting</a><a id="Prefix-automaton-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Prefix-automaton-rewriting" title="Permalink"></a></h2><p>Rewriting with a prefix automaton <code>pfxA</code> traces <code>w</code> through a non non-deterministic automaton which is <code>pfxA</code> with a <code>ε</code>-labeled loop added at its (unique) initial state. In tracing we follow <strong>all possible</strong> paths determined by <code>w</code>, i.e. in this case each path begins at every letter of <code>w</code>. Whenever a non-accepting state is encountered on <em>any</em> of the paths, the corresponding rule <code>lhs →  rhs</code> is used for rewriting.</p><p>This rewriting can be also understood differently: given the non-deterministic automaton one could determinize it through power-set construction and then trace deterministicaly in the automaton whose states are subsets of states of the initial automaton. Here we do it without realizing the power-set explicitly and we are tracing through a procedure described in Sims book as the <em>accessible subset construction</em>.</p><article><details class="docstring" open="true"><summary id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Automata.PrefixAutomaton}"><a class="docstring-binding" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Automata.PrefixAutomaton}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, pfxA::PrefixAutomaton[; history, skipping])</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> using prefix automaton <code>idxA</code>. As rewriting rules are stored <strong>externally</strong>, they must be passed in the <code>rules</code> keyword argument.</p><p>Rewriting with a <a href="../prefix_automaton/#KnuthBendix.Automata.PrefixAutomaton"><code>PrefixAutomaton</code></a> traces (i.e. follows) simultanously all paths in the automaton determined by <code>w</code>. To be more precise we trace a path in the power-set automaton (states are the subsets of states of the original automaton) via a prodedure described by Sims as the lazy <em>accessible subset construction</em>. Since the non-deterministic part of the automaton consists of <code>ε</code>-loop at the initial state there are at most <code>length(w)-1</code> such paths.</p><p>Whenever a non-accepting state is encountered <strong>on any</strong> of those paths</p><ol><li>its corresponding rule <code>lhs → rhs</code> is retrived,</li><li>the appropriate suffix of <code>v</code> (equal to <code>lhs</code>) is removed, and</li><li><code>rhs</code> is prepended to <code>w</code>.</li></ol><p>Tracing continues from the first letter of the newly prepended word.</p><p>To continue tracing <code>w</code> through the automaton we need to backtrack on our path in the automaton and for this <code>rewrite</code> maintains a history consisting of subsets of states of <code>pfxA</code>. Whenever a suffix is removed from <code>v</code>, the path is rewinded (i.e. shortened to the appropriate length) and the next letter of <code>w</code> is traced from the last state on the path. This maintains the property that signature of the path is equal to <code>v</code> at all times.</p><p>Once prefix automaton <code>pfxA</code> is build the complexity of this rewriting is <code>Ω(length(w) · max(length(w), m))</code>, where <code>m</code> is the number of states of <code>pfxA</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/ed3c4980c7bf37951e4d233a9786cbdeed23fa75/src/rewriting.jl#L279-L310">source</a></section></details></article><p>In practice the history consists of the subsets of states (of <code>pfxA</code>) which are stored in <code>PackedVector</code>, a contiguous array of states with separators. A new path is started whenever a new letter is pushed onto <code>v</code> by simply adding the the initial state of <code>pfxA</code> to the current subset. The rewinding of the history then happens simultanuously for all paths without additional book-keeping.</p><p>Once prefix automaton is build the complexity of this rewriting is achievable in realistically <strong>quadratic</strong> time with respect to the length of the rewritten word. This rewriting strikes a balance between the complexity of rewriting and the synchronization of <code>pfxA</code> and <code>ℒ</code>, as the insertion of a rule into <code>pfxA</code> has linear complexity and can be accomplished without reducing the automaton.</p><h3 id="Even-more-internals-of-rewriting"><a class="docs-heading-anchor" href="#Even-more-internals-of-rewriting">Even more internals of rewriting</a><a id="Even-more-internals-of-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Even-more-internals-of-rewriting" title="Permalink"></a></h3><h4 id="On-RewritingBuffers"><a class="docs-heading-anchor" href="#On-RewritingBuffers">On <code>RewritingBuffer</code>s</a><a id="On-RewritingBuffers-1"></a><a class="docs-heading-anchor-permalink" href="#On-RewritingBuffers" title="Permalink"></a></h4><p>Rewriting is a crucial part of the Knuth-Bendix completion. In particular we do care plenty not only about the theoretical complexity, but also the practical speed of rewriting. You may be surprised then that a simple <code>rewrite</code> allocates <code>6</code> times:</p><pre><code class="language-julia-repl hljs">julia&gt; alph = Alphabet([:a, :A, :b], [2,1,3])
Alphabet of Symbol
  1. a    (inverse of: A)
  2. A    (inverse of: a)
  3. b    (self-inverse)

julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; w = a*A*b^3;

julia&gt; @time KnuthBendix.rewrite(w, alph)
  0.000015 seconds (7 allocations: 336 bytes)
Word{UInt16}: 3
</code></pre><p>This is because the system is tuned towards re-using the storage in the process of the completion. In particular a <a href="#KnuthBendix.RewritingBuffer"><code>RewritingBuffer</code></a> consisting of two <a href="../words/#KnuthBendix.Words.BufferWord"><code>Words.BufferWord</code></a> and the final returned word (of the same type as <code>w</code>) are allocated in the process:</p><pre><code class="language-julia hljs">function rewrite(
    w::W,
    rewriting,
    rwbuffer::RewritingBuffer = RewritingBuffer{T}(rewriting),
    kwargs...,
) where {T,W&lt;:AbstractWord{T}}
    # first copy the content of w into rwbuffer
    Words.store!(rwbuffer, w)
    # then rewrite reusing the internal BufferWords
    rewrite!(rwbuffer, rewriting; kwargs...)
    # finally take ownership of the result
    return W(rwbuffer.output)
end</code></pre><article><details class="docstring" open="true"><summary id="KnuthBendix.RewritingBuffer"><a class="docstring-binding" href="#KnuthBendix.RewritingBuffer"><code>KnuthBendix.RewritingBuffer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RewritingBuffer{T}()
RewritingBuffer{T}(history::AbstractVector)</code></pre><p>A pair of <a href="../words/#KnuthBendix.Words.BufferWord"><code>BufferWords</code></a> used for efficient rewriting of words with letters of type {T}.</p><p>Additional <code>history</code> may be passed to construct a buffer for rewriting with an appropriate automaton. See methods of <a href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Rule}"><code>rewrite!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/ed3c4980c7bf37951e4d233a9786cbdeed23fa75/src/buffer_pair.jl#L1-L8">source</a></section></details></article><p><a href="../words/#KnuthBendix.Words.BufferWord"><code>Words.BufferWord</code></a> is an implementation of <a href="../words/#KnuthBendix.Words.AbstractWord"><code>AbstractWord</code></a> tuned for the purpose of this form of rewriting (with <code>O(1)</code> complexity for <code>popfirst!</code>, <code>push!</code> and <code>prepend!</code>). In the Knuth-Bendix completion these <code>RewritingBuffer</code>s are allocated only once per run and re-used later, so that destructive rewriting is as free from allocations and memory copy as possible.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Sims1994"><a class="tag is-link" href="#citeref-Sims1994">Sims1994</a>C.C. Sims <em>Computation with finitely presented groups</em>,          Cambridge University Press, 1994.</li><li class="footnote" id="footnote-Sims1994"><a class="tag is-link" href="#citeref-Sims1994">Sims1994</a>C.C. Sims <em>Computation with finitely presented groups</em>,          Cambridge University Press, 1994.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../orders/">« Orders</a><a class="docs-footer-nextpage" href="../rewriting_system/">Rewriting System »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 7 December 2025 21:01">Sunday 7 December 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

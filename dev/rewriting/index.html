<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>On rewriting · KnuthBendix.jl</title><meta name="title" content="On rewriting · KnuthBendix.jl"/><meta property="og:title" content="On rewriting · KnuthBendix.jl"/><meta property="twitter:title" content="On rewriting · KnuthBendix.jl"/><meta name="description" content="Documentation for KnuthBendix.jl."/><meta property="og:description" content="Documentation for KnuthBendix.jl."/><meta property="twitter:description" content="Documentation for KnuthBendix.jl."/><meta property="og:url" content="https://kalmarek.github.io/KnuthBendix.jl/rewriting/"/><meta property="twitter:url" content="https://kalmarek.github.io/KnuthBendix.jl/rewriting/"/><link rel="canonical" href="https://kalmarek.github.io/KnuthBendix.jl/rewriting/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KnuthBendix.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory/">Monoids and the word problem</a></li><li><a class="tocitem" href="../knuthbendix_completion/">Confluence and the Knuth-Bendix completion</a></li></ul></li><li><span class="tocitem">Words and Alphabets</span><ul><li><a class="tocitem" href="../words/">Words</a></li><li><a class="tocitem" href="../alphabets/">Alphabets</a></li><li><a class="tocitem" href="../orders/">Orders</a></li></ul></li><li><span class="tocitem">Rewriting</span><ul><li class="is-active"><a class="tocitem" href>On rewriting</a><ul class="internal"><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li class="toplevel"><a class="tocitem" href="#Particular-implementations-of-rewriting."><span>Particular implementations of rewriting.</span></a></li><li><a class="tocitem" href="#Naive-rewriting"><span>Naive rewriting</span></a></li><li><a class="tocitem" href="#Index-automaton"><span>Index automaton</span></a></li><li><a class="tocitem" href="#Non-deterministic-prefix-automaton"><span>Non-deterministic prefix automaton</span></a></li></ul></li><li><a class="tocitem" href="../rewriting_system/">Rewriting System</a></li></ul></li><li><span class="tocitem">Knuth-Bendix completion</span><ul><li><a class="tocitem" href="../KB_implementations/">Implementations of Knuth-Bendix completion</a></li><li><a class="tocitem" href="../knuthbendix1/">Naive</a></li><li><a class="tocitem" href="../knuthbendix2/">Using a stack</a></li><li><a class="tocitem" href="../knuthbendix_idxA/">Using index automaton</a></li></ul></li><li><span class="tocitem">Automata</span><ul><li><a class="tocitem" href="../automata/">Interface</a></li><li><a class="tocitem" href="../backtrack/">Backtrack searches</a></li><li><a class="tocitem" href="../index_automaton/">-</a></li><li><a class="tocitem" href="../prefix_automaton/">-</a></li></ul></li><li><a class="tocitem" href="../parsing_kbmag/">Parsing <code>kbmag</code> input files</a></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../nc_groebner/">Non-commutative Gröbner bases</a></li><li><a class="tocitem" href="../builtin_examples/">Example rewriting systems</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rewriting</a></li><li class="is-active"><a href>On rewriting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>On rewriting</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl/blob/master/docs/src/rewriting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="On-rewriting"><a class="docs-heading-anchor" href="#On-rewriting">On rewriting</a><a id="On-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#On-rewriting" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.rewrite" href="#KnuthBendix.rewrite"><code>KnuthBendix.rewrite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rewrite(u::AbstractWord, rewriting)</code></pre><p>Rewrites word <code>u</code> using the <code>rewriting</code> object. The object must implement <code>rewrite!(v::AbstractWord, w::AbstractWord, rewriting)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alph = Alphabet([:a, :A, :b], [2,1,3])
Alphabet of Symbol
  1. a    (inverse of: A)
  2. A    (inverse of: a)
  3. b    (self-inverse)

julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; rule = KnuthBendix.Rule(a*b =&gt; a)
1·3 ⇒ 1

julia&gt; KnuthBendix.rewrite(a*b^2*A*b^3, rule) == a*A*b^3
true

julia&gt; KnuthBendix.rewrite(a*A*b^3, alph) == b
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/fd36e758c564c52bb5b7eed05bf99c17a4c46d46/src/rewriting.jl#L1-L26">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><p>Implementing rewriting procedure naively could easily lead to quadratic complexity due to unnecessary moves of parts of the rewritten word. The linear-complexity algorithm uses two stacks <code>v</code> and <code>w</code>:</p><ul><li><code>v</code> is initially empty (represents the trivial word), while</li><li><code>w</code> contains the content of <code>u</code> (the word to be rewritten with its first letter on its top).</li></ul><div class="admonition is-info"><header class="admonition-header">Rewriting algorithm</header><div class="admonition-body"><ol><li>we pop the first letter <code>l = popfirst!(w)</code> from <code>w</code>,</li><li>we push <code>l</code> to the end of <code>v</code>,</li><li>we determine a rewritng rule (if it exists) <code>lhs → rhs</code> with <code>v = v&#39;·lhs</code> (i.e. <code>lhs</code> is equal to a suffix of <code>v</code>), and we set<ul><li><code>v ← v&#39;</code> i.e. we remove the suffix fom <code>v</code>, and</li><li><code>w ← rhs·w</code> i.e. <code>rhs</code> is <em>prepended</em> to <code>w</code></li></ul></li><li>if no such rule exists we go back to 1.</li></ol><p>These four steps are repeated until <code>w</code> becomes empty.</p></div></div><p>In julia flavoured pseudocode the rewrite procedure looks as follows:</p><pre><code class="language-julia hljs">function rewrite!(v::AbstractWord, w::AbstractWord, rewriting; kwargs...)
    while !isone(w)
        push!(v, popfirst!(w))
        res = find_rule_with_suffix(rewriting, v)
        isnothing(res) &amp;&amp; continue # no rule matching was found
        (lhs, rhs) = res
        @assert v[end-length(lhs)+1:end] == lhs # i.e. v = v&#39;·lhs
        resize!(v, length(v)-length(lhs)) # v ← v&#39;
        prepend!(w, rhs) # w ← rhs·w
    end
    return v
end</code></pre><p>In practice our implementations in place of stacks use <a href="../words/#KnuthBendix.Words.BufferWord"><code>BufferWord</code>s</a> (a special implementation of the <code>AbstractWord</code> API).</p><h1 id="Particular-implementations-of-rewriting."><a class="docs-heading-anchor" href="#Particular-implementations-of-rewriting.">Particular implementations of rewriting.</a><a id="Particular-implementations-of-rewriting.-1"></a><a class="docs-heading-anchor-permalink" href="#Particular-implementations-of-rewriting." title="Permalink"></a></h1><p>Here are some examples of the internal rewriting function already defined:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Rule}" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Rule}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, rule::Rule)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> by using a single rewriting <code>rule</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; rule = KnuthBendix.Rule(a*b =&gt; a)
1·3 ⇒ 1

julia&gt; v = one(a); KnuthBendix.rewrite!(v, a*b^2*A*b^3, rule);

julia&gt; v == a*A*b^3
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/fd36e758c564c52bb5b7eed05bf99c17a4c46d46/src/rewriting.jl#L49-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, Alphabet}" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, Alphabet}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, A::Alphabet)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> by applying free reductions as defined by the inverses present in alphabet <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alph = Alphabet([:a, :A, :b], [2,1,3])
Alphabet of Symbol
  1. a    (inverse of: A)
  2. A    (inverse of: a)
  3. b    (self-inverse)

julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; v = one(a); KnuthBendix.rewrite!(v, a*b^2*A*b^3, alph);

julia&gt; v == b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/fd36e758c564c52bb5b7eed05bf99c17a4c46d46/src/rewriting.jl#L84-L104">source</a></section></article><hr/><p>Let a rewriting system <code>rws</code> is given, and let <code>lhsₖ → rhsₖ</code> denote its <code>k</code>-th rule. Let <code>ℒ = {lhsₖ}ₖ</code> denote the language of left-hand-sides of <code>rws</code> and let <code>N = Σₖ length(lhsₖ)</code> be the total length of <code>ℒ</code>.</p><h2 id="Naive-rewriting"><a class="docs-heading-anchor" href="#Naive-rewriting">Naive rewriting</a><a id="Naive-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-rewriting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, RewritingSystem}" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, RewritingSystem}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, rws::RewritingSystem)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> using rewriting rules of <code>rws</code>.</p><p>The naive rewriting with <a href="../rewriting_system/#KnuthBendix.RewritingSystem">`RewritingSystem</a></p><ol><li>moves one letter from the beginning of <code>w</code> to the end of <code>v</code></li><li>checks every rule <code>lhs → rhs</code> in <code>rws</code> until <code>v</code> contains <code>lhs</code> as a</li></ol><p>suffix,</p><ol><li>if found, the suffix is removed from <code>v</code> and <code>rhs</code> is prepended to <code>w</code>.</li></ol><p>Those steps repeat until <code>w</code> is empty.</p><p>The complexity of this rewriting is <code>Ω(length(u) · N)</code>, where <code>N</code> is the total size of left hand sides of the rewriting rules of <code>rws</code>.</p><p>See procedure <code>REWRITE_FROM_LEFT</code> from <strong>Section 2.4</strong><sup class="footnote-reference"><a id="citeref-Sims1994" href="#footnote-Sims1994">[Sims1994]</a></sup>, p. 66.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/fd36e758c564c52bb5b7eed05bf99c17a4c46d46/src/rewriting.jl#L128-L148">source</a></section></article><p>The naive rewriting with  a rewriting system is therefore in the worst case <strong>proportional</strong> to the total size of the whole <code>rws</code> which makes it a very inefficient rewriting strategy.</p><h2 id="Index-automaton"><a class="docs-heading-anchor" href="#Index-automaton">Index automaton</a><a id="Index-automaton-1"></a><a class="docs-heading-anchor-permalink" href="#Index-automaton" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Automata.IndexAutomaton}" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Automata.IndexAutomaton}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, idxA::Automata.IndexAutomaton)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> using index automaton <code>idxA</code>.</p><p>Rewriting with an <a href="@ref Automata.IndexAutomaton"><code>IndexAutomaton</code></a> traces (i.e. follows) the path in the automaton determined by <code>w</code> (since the automaton is deterministic there is only one such path). Whenever a terminal (i.e. accepting) state is encountered</p><ol><li>its corresponding rule <code>lhs → rhs</code> is retrived,</li><li>the appropriate suffix of <code>v</code> (equal to <code>lhs</code>) is removed, and</li><li><code>rhs</code> is prepended to <code>w</code>.</li></ol><p>Tracing continues from the newly prepended letter.</p><p>To continue tracing <code>w</code> through the automaton we need to backtrack on our path in the automaton and for this <code>rewrite</code> maintains a vector of visited states of <code>idxA</code> (the history of visited states of <code>idxA</code>). Whenever a suffix is removed from <code>v</code>, the path is rewinded (i.e. shortened) to the appropriate length and the next letter of <code>w</code> is traced from the last state on the path. This maintains the property that signature of the path is equal to <code>v</code> at all times.</p><p>Once index automaton is build the complexity of this rewriting is <code>Ω(length(w))</code> which is the optimal rewriting strategy.</p><p>See procedure <code>INDEX_REWRITE</code> from <strong>Section 3.5</strong><sup class="footnote-reference"><a id="citeref-Sims1994" href="#footnote-Sims1994">[Sims1994]</a></sup>, p. 113.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/fd36e758c564c52bb5b7eed05bf99c17a4c46d46/src/rewriting.jl#L171-L200">source</a></section></article><p>In practice the complexity of building and maintaining <code>idxA</code> synchronized with <code>ℒ</code> overwhelms gains made in rewriting (to construct <code>idxA</code> one need to <em>reduce</em> <code>rws</code> first which is <code>O(N²)</code> (??)).</p><h2 id="Non-deterministic-prefix-automaton"><a class="docs-heading-anchor" href="#Non-deterministic-prefix-automaton">Non-deterministic prefix automaton</a><a id="Non-deterministic-prefix-automaton-1"></a><a class="docs-heading-anchor-permalink" href="#Non-deterministic-prefix-automaton" title="Permalink"></a></h2><p>Rewriting with a non-deterministic prefix automaton <code>pfxA</code> traces the whole set of paths in <code>pfxA</code> which are determined by <code>w</code>. Since <code>pfxA</code> contains an <code>ε</code>-labeled loop at its (unique) initial state, tracing <code>w</code> through <code>pfxA</code> amounts to tracing a set of paths where each begins at every letter of <code>w</code>. Whenever a terminal (i.e. accepting) state is encountered on <em>any</em> of the paths, the corresponding rule <code>lhs →  rhs</code> is retrived, the appropriate suffix of <code>v</code> (equal to <code>lhs</code>) is removed, and <code>rhs</code> is prepended to <code>w</code>.</p><p>As above, to continue tracing the set of paths we need to backtrack each path and for this <code>rewrite</code> maintains the histories of visited states of <code>pfxA</code> for each path. Whenever a suffix is removed from <code>v</code> each path must be rewinded by an appropriate length.</p><p>This rewriting can be also understood differently: given the non-deterministic automaton <code>pfxA</code> one could determinize it through power-set construction and then trace deterministicaly in the automaton whose states are subsets of states of <code>pfxA</code>. Here we do it without realizing the power-set explicitly and we are tracing through procedute described in Sims as <em>accessible subset construction</em>.</p><p>In practice the history consists of the subsets of states (of <code>pfxA</code>) which are stored in a contiguous array and an additional vector of indices marking the separation indices is added. A new path is started whenever a new letter is pushed onto <code>v</code> by simply adding the the initial state of <code>pfxA</code> to the current subset. The rewinding of the history then can be done simultanuously for all paths (without much bookkeeping) by shortening the vector of separators and resizing contiguous array of states accordingly.</p><p>Once prefix automaton is build the complexity of this rewriting is <code>Ω(m²)</code>. This rewriting strikes a balance between the complexity of rewriting and the synchronization of <code>pfxA</code> and <code>ℒ</code>, as the insertion and the removal of a word <code>w</code> to <code>pfxA</code> has complexity <code>O(m)</code>.</p><h3 id="Even-more-internals-of-rewriting"><a class="docs-heading-anchor" href="#Even-more-internals-of-rewriting">Even more internals of rewriting</a><a id="Even-more-internals-of-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Even-more-internals-of-rewriting" title="Permalink"></a></h3><h4 id="On-BufferWords"><a class="docs-heading-anchor" href="#On-BufferWords">On <code>BufferWord</code>s</a><a id="On-BufferWords-1"></a><a class="docs-heading-anchor-permalink" href="#On-BufferWords" title="Permalink"></a></h4><p>Rewriting is a crucial part of the Knuth-Bendix completion. In particular we do care plenty not only about the theoretical complexity, but also the practical speed of rewriting. You may be surprised then that a simple <code>rewrite</code> allocates <code>6</code> times:</p><pre><code class="language-julia-repl hljs">julia&gt; alph = Alphabet([:a, :A, :b], [2,1,3])
Alphabet of Symbol
  1. a    (inverse of: A)
  2. A    (inverse of: a)
  3. b    (self-inverse)

julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; w = a*A*b^3;

julia&gt; @time KnuthBendix.rewrite(w, alph)
  0.000015 seconds (6 allocations: 272 bytes)
Word{UInt16}: 3
</code></pre><p>This is because the system is tuned towards re-using the storage in the process of the completion. In particular two <a href="../words/#KnuthBendix.Words.BufferWord"><code>Words.BufferWord</code></a> and the final returned word (of the same type as <code>w</code>) are allocated in the process:</p><pre><code class="language-julia hljs">function rewrite(
    w::W,
    rewriting,
    vbuff = Words.BufferWord{T}(0, length(u)),
    wbuff = Words.BufferWord{T}(0, length(u));
    kwargs...,
) where {T,W&lt;:AbstractWord{T}}
    # first copy the content of w into wbuff then
    rewrite!(vbuff, wbuff, rewriting; kwargs...)
    # finally take ownership of the content of vbuff
    return W(vbuff)
end</code></pre><p><a href="../words/#KnuthBendix.Words.BufferWord"><code>Words.BufferWord</code></a> is an implementation of <a href="../words/#KnuthBendix.Words.AbstractWord"><code>AbstractWord</code></a> tuned for the purpose of this form of rewriting (with <code>O(1)</code> complexity for <code>popfirst!</code>, <code>push!</code> and <code>prepend!</code>). In the Knuth-Bendix completion these <code>BufferWord</code>s are allocated only once per run and re-used as much as possible, so that destructive rewriting is as free from allocations and memory copy as possible.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Sims1994"><a class="tag is-link" href="#citeref-Sims1994">Sims1994</a>C.C. Sims <em>Computation with finitely presented groups</em>,          Cambridge University Press, 1994.</li><li class="footnote" id="footnote-Sims1994"><a class="tag is-link" href="#citeref-Sims1994">Sims1994</a>C.C. Sims <em>Computation with finitely presented groups</em>,          Cambridge University Press, 1994.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../orders/">« Orders</a><a class="docs-footer-nextpage" href="../rewriting_system/">Rewriting System »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 9 July 2024 14:46">Tuesday 9 July 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

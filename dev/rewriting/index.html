<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>On rewriting · KnuthBendix.jl</title><meta name="title" content="On rewriting · KnuthBendix.jl"/><meta property="og:title" content="On rewriting · KnuthBendix.jl"/><meta property="twitter:title" content="On rewriting · KnuthBendix.jl"/><meta name="description" content="Documentation for KnuthBendix.jl."/><meta property="og:description" content="Documentation for KnuthBendix.jl."/><meta property="twitter:description" content="Documentation for KnuthBendix.jl."/><meta property="og:url" content="https://kalmarek.github.io/KnuthBendix.jl/rewriting/"/><meta property="twitter:url" content="https://kalmarek.github.io/KnuthBendix.jl/rewriting/"/><link rel="canonical" href="https://kalmarek.github.io/KnuthBendix.jl/rewriting/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KnuthBendix.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory/">Monoids and the word problem</a></li><li><a class="tocitem" href="../knuthbendix_completion/">Confluence and the Knuth-Bendix completion</a></li></ul></li><li><span class="tocitem">Words and Alphabets</span><ul><li><a class="tocitem" href="../words/">Words</a></li><li><a class="tocitem" href="../alphabets/">Alphabets</a></li><li><a class="tocitem" href="../orders/">Orders</a></li></ul></li><li><span class="tocitem">Rewriting</span><ul><li class="is-active"><a class="tocitem" href>On rewriting</a><ul class="internal"><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#Naive-rewriting"><span>Naive rewriting</span></a></li><li><a class="tocitem" href="#Index-automaton"><span>Index automaton</span></a></li><li><a class="tocitem" href="#Non-deterministic-prefix-automaton"><span>Non-deterministic prefix automaton</span></a></li></ul></li><li><a class="tocitem" href="../rewriting_system/">Rewriting System</a></li></ul></li><li><span class="tocitem">Knuth-Bendix completion</span><ul><li><a class="tocitem" href="../KB_implementations/">Implementations of Knuth-Bendix completion</a></li><li><a class="tocitem" href="../knuthbendix1/">Naive</a></li><li><a class="tocitem" href="../knuthbendix2/">Using a stack</a></li><li><a class="tocitem" href="../knuthbendix_idxA/">Using index automaton</a></li></ul></li><li><a class="tocitem" href="../parsing_kbmag/">Parsing <code>kbmag</code> input files</a></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../nc_groebner/">Non-commutative Gröbner bases</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rewriting</a></li><li class="is-active"><a href>On rewriting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>On rewriting</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl/blob/master/docs/src/rewriting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="On-rewriting"><a class="docs-heading-anchor" href="#On-rewriting">On rewriting</a><a id="On-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#On-rewriting" title="Permalink"></a></h1><pre><code class="language- hljs">rewrite</code></pre><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><p>The general rewriting follows the <em>destructive</em> semantics in which <code>rewrite</code> function calls internally</p><pre><code class="language-julia hljs">function rewrite!(v::AbstractWord, w::AbstractWord, rewriting; kwargs...)
    ...
    return v
end</code></pre><p>The semantics are that <code>v</code> can be thought of as initially trivial (i.e. empty) word, and we want to rewrite <code>w</code> <strong>onto</strong> <code>v</code>. In all our implementations the process follows as follows</p><ol><li>we pop the first letter <code>l = popfirst!(w)</code> from <code>w</code>,</li><li>we push <code>l</code> to the end of <code>v</code>,</li><li>we try to determine a rewritng rule <code>lhs → rhs</code> with <code>v = v&#39;·lhs</code> (i.e. <code>lhs</code> is equal to a suffix of <code>v</code>) and we set<ul><li><code>v ← v&#39;</code> i.e. we remove the suffix fom <code>v</code>, and</li><li><code>w ← rhs·w</code> i.e. <code>rhs</code> is <em>prepended</em> to <code>w</code></li></ul></li><li>if no such rule exists we go back to 1.</li></ol><p>These four steps are repeated until <code>w</code> becomes empty.</p><p>Here are some examples of the internal rewriting function already defined:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Rule}" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Rule}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, rule::Rule)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> by using a single rewriting <code>rule</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; rule = KnuthBendix.Rule(a*b =&gt; a)
1·3 ⇒ 1

julia&gt; v = one(a); KnuthBendix.rewrite!(v, a*b^2*A*b^3, rule);

julia&gt; v == a*A*b^3
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/c9590de0c416368deb06717b122a3e674bc73999/src/rewriting.jl#L50-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, Alphabet}" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, Alphabet}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, A::Alphabet)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> by applying free reductions as defined by the inverses present in alphabet <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alph = Alphabet([:a, :A, :b], [2,1,3])
Alphabet of Symbol
  1. a    (inverse of: A)
  2. A    (inverse of: a)
  3. b    (self-inverse)

julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; v = one(a); KnuthBendix.rewrite!(v, a*b^2*A*b^3, alph);

julia&gt; v == b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/c9590de0c416368deb06717b122a3e674bc73999/src/rewriting.jl#L80-L100">source</a></section></article><p>Let a rewriting system <code>rws</code> is given, and let <code>lhsₖ → rhsₖ</code> denote its <code>k</code>-th rule. Let <code>ℒ = {lhsₖ}ₖ</code> denote the language of left-hand-sides of <code>rws</code> and let <code>N = Σₖ nₖ</code> be the total length of <code>ℒ</code>.</p><h2 id="Naive-rewriting"><a class="docs-heading-anchor" href="#Naive-rewriting">Naive rewriting</a><a id="Naive-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-rewriting" title="Permalink"></a></h2><p>The naive version is to check for every rule <code>lhs → rhs</code> in <code>rws</code> if <code>v</code> contains <code>lhs</code> as a suffix. If so, the suffix is removed from <code>v</code>, <code>rhs</code> is prepended to <code>w</code> and we move to the (new) first letter of <code>w</code>. With <code>m = length(u)</code> the complexity of this rewriting is <code>Ω(m · N)</code>, i.e. it is <strong>proportional</strong> to the size of the whole rewriting system making it a very inefficient rewriting strategy.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, RewritingSystem}" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, RewritingSystem}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, rws::RewritingSystem)</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> using rewriting rules of <code>rws</code>.</p><p>See procedure <code>REWRITE_FROM_LEFT</code> from <strong>Section 2.4</strong><sup class="footnote-reference"><a id="citeref-Sims1994" href="#footnote-Sims1994">[Sims1994]</a></sup>, p. 66.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/c9590de0c416368deb06717b122a3e674bc73999/src/rewriting.jl#L119-L127">source</a></section></article><h2 id="Index-automaton"><a class="docs-heading-anchor" href="#Index-automaton">Index automaton</a><a id="Index-automaton-1"></a><a class="docs-heading-anchor-permalink" href="#Index-automaton" title="Permalink"></a></h2><p>Rewriting with an index automaton <code>idxA</code> traces (follows) the path in the automaton determined by <code>w</code> (since the automaton is deterministic there is only one such path). Whenever a terminal (i.e. accepting) state is encountered its corresponding rule <code>lhs → rhs</code> is retrived, the appropriate suffix of <code>v</code> (equal to <code>lhs</code>) is removed, and <code>rhs</code> is prepended to <code>w</code>. Tracing continues from the newly prepended letter.</p><p>To continue tracing <code>w</code> through the automaton we need to backtrack on our path in the automaton and for this <code>rewrite</code> maintains a vector of visited states of <code>idxA</code> (the history of visited states of <code>idxA</code>). Whenever a suffix is removed from <code>v</code>, the path is rewinded (i.e. shortened) to the appropriate length and the next letter of <code>w</code> is traced from the last state on the path. This maintains the property that signature of the path is equal to <code>v</code> at all times.</p><p>Once index automaton is build the complexity of this rewriting is <code>Ω(m)</code> which is the optimal rewriting strategy. In practice the complexity of building and maintaining <code>idxA</code> synchronized with <code>ℒ</code> overwhelms gains made in rewriting (to construct <code>idxA</code> one need to <em>reduce</em> <code>rws</code> first which is <code>O(N²)</code> (??)).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Automata.IndexAutomaton}" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord, KnuthBendix.Automata.IndexAutomaton}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(v::AbstractWord, w::AbstractWord, idxA::Automata.IndexAutomaton;
    [history])</code></pre><p>Rewrite word <code>w</code> storing the result in <code>v</code> using index automaton <code>idx</code>.</p><p>See procedure <code>INDEX_REWRITE</code> from <strong>Section 3.5</strong><sup class="footnote-reference"><a id="citeref-Sims1994" href="#footnote-Sims1994">[Sims1994]</a></sup>, p. 113.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/c9590de0c416368deb06717b122a3e674bc73999/src/rewriting.jl#L149-L158">source</a></section></article><h2 id="Non-deterministic-prefix-automaton"><a class="docs-heading-anchor" href="#Non-deterministic-prefix-automaton">Non-deterministic prefix automaton</a><a id="Non-deterministic-prefix-automaton-1"></a><a class="docs-heading-anchor-permalink" href="#Non-deterministic-prefix-automaton" title="Permalink"></a></h2><p>Rewriting with a non-deterministic prefix automaton <code>pfxA</code> traces the whole set of paths in <code>pfxA</code> which are determined by <code>w</code>. Since <code>pfxA</code> contains an <code>ε</code>-labeled loop at its (unique) initial state, tracing <code>w</code> through <code>pfxA</code> amounts to tracing a set of paths where each begins at every letter of <code>w</code>. Whenever a terminal (i.e. accepting) state is encountered on <em>any</em> of the paths, the corresponding rule <code>lhs →  rhs</code> is retrived, the appropriate suffix of <code>v</code> (equal to <code>lhs</code>) is removed, and <code>rhs</code> is prepended to <code>w</code>.</p><p>As above, to continue tracing the set of paths we need to backtrack each path and for this <code>rewrite</code> maintains the histories of visited states of <code>pfxA</code> for each path. Whenever a suffix is removed from <code>v</code> each path must be rewinded by an appropriate length.</p><p>This rewriting can be also understood differently: given the non-deterministic automaton <code>pfxA</code> one could determinize it through power-set construction and then trace deterministicaly in the automaton whose states are subsets of states of <code>pfxA</code>. Here we do it without realizing the power-set explicitly and we are tracing through procedute described in Sims as <em>accessible subset construction</em>.</p><p>In practice the history consists of the subsets of states (of <code>pfxA</code>) which are stored in a contiguous array and an additional vector of indices marking the separation indices is added. A new path is started whenever a new letter is pushed onto <code>v</code> by simply adding the the initial state of <code>pfxA</code> to the current subset. The rewinding of the history then can be done simultanuously for all paths (without much bookkeeping) by shortening the vector of separators and resizing contiguous array of states accordingly.</p><p>Once prefix automaton is build the complexity of this rewriting is <code>Ω(m²)</code>. This rewriting strikes a balance between the complexity of rewriting and the synchronization of <code>pfxA</code> and <code>ℒ</code>, as the insertion and the removal of a word <code>w</code> to <code>pfxA</code> has complexity <code>O(m)</code>.</p><h3 id="Even-more-internals-of-rewriting"><a class="docs-heading-anchor" href="#Even-more-internals-of-rewriting">Even more internals of rewriting</a><a id="Even-more-internals-of-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Even-more-internals-of-rewriting" title="Permalink"></a></h3><h4 id="On-BufferWords"><a class="docs-heading-anchor" href="#On-BufferWords">On <code>BufferWord</code>s</a><a id="On-BufferWords-1"></a><a class="docs-heading-anchor-permalink" href="#On-BufferWords" title="Permalink"></a></h4><p>Rewriting is a crucial part of the Knuth-Bendix completion. In particular we do care plenty not only about the theoretical complexity, but also the practical speed of rewriting. You may be surprised then that a simple <code>rewrite</code> allocates <code>6</code> times:</p><pre><code class="language-julia-repl hljs">julia&gt; alph = Alphabet([:a, :A, :b], [2,1,3])
Alphabet of Symbol
  1. a    (inverse of: A)
  2. A    (inverse of: a)
  3. b    (self-inverse)

julia&gt; a = Word([1]); A = Word([2]); b = Word([3]);

julia&gt; w = a*A*b^3;

julia&gt; @time KnuthBendix.rewrite(w, alph)
  0.000015 seconds (6 allocations: 272 bytes)
Word{UInt16}: 3
</code></pre><p>This is because the system is tuned towards re-using the storage in the process of the completion. In particular two <a href="../words/#KnuthBendix.Words.BufferWord"><code>Words.BufferWord</code></a> and the final returned word (of the same type as <code>w</code>) are allocated in the process:</p><pre><code class="language-julia hljs">function rewrite(
    w::W,
    rewriting,
    vbuff = Words.BufferWord{T}(0, length(u)),
    wbuff = Words.BufferWord{T}(0, length(u));
    kwargs...,
) where {T,W&lt;:AbstractWord{T}}
    # first copy the content of w into wbuff then
    rewrite!(vbuff, wbuff, rewriting; kwargs...)
    # finally take ownership of the content of vbuff
    return W(vbuff)
end</code></pre><p><a href="../words/#KnuthBendix.Words.BufferWord"><code>Words.BufferWord</code></a> is an implementation of <a href="../words/#KnuthBendix.Words.AbstractWord"><code>AbstractWord</code></a> tuned for the purpose of this form of rewriting (with <code>O(1)</code> complexity for <code>popfirst!</code>, <code>push!</code> and <code>prepend!</code>). In the Knuth-Bendix completion these <code>BufferWord</code>s are allocated only once per run and re-used as much as possible, so that destructive rewriting is as free from allocations and memory copy as possible.</p><p>In particular rewriting with <code>BufferPair</code> saves all of those allocations at the cost of owning the result:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.rewrite!-Tuple{KnuthBendix.BufferPair, KnuthBendix.Words.AbstractWord, Any}" href="#KnuthBendix.rewrite!-Tuple{KnuthBendix.BufferPair, KnuthBendix.Words.AbstractWord, Any}"><code>KnuthBendix.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function rewrite!(bp::BufferPair, u::AbstractWord, rewriting)</code></pre><p>Rewrites a word from left using buffer words from <code>BufferPair</code> and <code>rewriting</code> object.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This implementation returns an instance of <code>Words.BufferWord</code> aliased with the intenrals of <code>BufferPair</code>. You need to copy the return value if you want to take the ownership.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/c9590de0c416368deb06717b122a3e674bc73999/src/helper_structures.jl#L32-L40">source</a></section></article><p><code>BufferPair</code> is just a convinience struct that bundles everything for allocation-free rewriting. While it is used extensively during Knuth-Bendix completion you should never see it outside of it!</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Sims1994"><a class="tag is-link" href="#citeref-Sims1994">Sims1994</a>C.C. Sims <em>Computation with finitely presented groups</em>,          Cambridge University Press, 1994.</li><li class="footnote" id="footnote-Sims1994"><a class="tag is-link" href="#citeref-Sims1994">Sims1994</a>C.C. Sims <em>Computation with finitely presented groups</em>,          Cambridge University Press, 1994.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../orders/">« Orders</a><a class="docs-footer-nextpage" href="../rewriting_system/">Rewriting System »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Monday 2 October 2023 10:34">Monday 2 October 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

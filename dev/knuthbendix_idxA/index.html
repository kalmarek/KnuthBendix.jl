<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using index automaton · KnuthBendix.jl</title><meta name="title" content="Using index automaton · KnuthBendix.jl"/><meta property="og:title" content="Using index automaton · KnuthBendix.jl"/><meta property="twitter:title" content="Using index automaton · KnuthBendix.jl"/><meta name="description" content="Documentation for KnuthBendix.jl."/><meta property="og:description" content="Documentation for KnuthBendix.jl."/><meta property="twitter:description" content="Documentation for KnuthBendix.jl."/><meta property="og:url" content="https://kalmarek.github.io/KnuthBendix.jl/knuthbendix_idxA/"/><meta property="twitter:url" content="https://kalmarek.github.io/KnuthBendix.jl/knuthbendix_idxA/"/><link rel="canonical" href="https://kalmarek.github.io/KnuthBendix.jl/knuthbendix_idxA/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KnuthBendix.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory/">Monoids and the word problem</a></li><li><a class="tocitem" href="../knuthbendix_completion/">Confluence and the Knuth-Bendix completion</a></li></ul></li><li><span class="tocitem">Words and Alphabets</span><ul><li><a class="tocitem" href="../words/">Words</a></li><li><a class="tocitem" href="../alphabets/">Alphabets</a></li><li><a class="tocitem" href="../orders/">Orders</a></li></ul></li><li><span class="tocitem">Rewriting</span><ul><li><a class="tocitem" href="../rewriting/">On rewriting</a></li><li><a class="tocitem" href="../rewriting_system/">Rewriting System</a></li></ul></li><li><span class="tocitem">Knuth-Bendix completion</span><ul><li><a class="tocitem" href="../KB_implementations/">Implementations of Knuth-Bendix completion</a></li><li><a class="tocitem" href="../knuthbendix1/">Naive</a></li><li><a class="tocitem" href="../knuthbendix2/">Using a stack</a></li><li class="is-active"><a class="tocitem" href>Using index automaton</a><ul class="internal"><li><a class="tocitem" href="#Backtrack-search-and-the-test-for-(local)-confluence"><span>Backtrack search and the test for (local) confluence</span></a></li></ul></li><li><a class="tocitem" href="../knuthbendix_pfxA/">Using prefix automaton</a></li></ul></li><li><span class="tocitem">Automata</span><ul><li><a class="tocitem" href="../automata/">Interface</a></li><li><a class="tocitem" href="../backtrack/">Backtrack searches</a></li><li><a class="tocitem" href="../index_automaton/">Index Automaton</a></li><li><a class="tocitem" href="../prefix_automaton/">Prefix Automaton</a></li></ul></li><li><a class="tocitem" href="../parsing_kbmag/">Parsing <code>kbmag</code> input files</a></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../nc_groebner/">Non-commutative Gröbner bases</a></li><li><a class="tocitem" href="../builtin_examples/">Example rewriting systems</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Knuth-Bendix completion</a></li><li class="is-active"><a href>Using index automaton</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using index automaton</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl/blob/master/docs/src/knuthbendix_idxA.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Using-index-automaton"><a class="docs-heading-anchor" href="#Using-index-automaton">Using index automaton</a><a id="Using-index-automaton-1"></a><a class="docs-heading-anchor-permalink" href="#Using-index-automaton" title="Permalink"></a></h1><p>Major speedups in rewriting can be obtained by using a specialized data structure for rewriting system. The structure is known in the contex<sup class="footnote-reference"><a id="citeref-Sims1994" href="#footnote-Sims1994">[Sims1994]</a></sup> of Knuth-Bendix completion as an <a href="../index_automaton/#KnuthBendix.Automata.IndexAutomaton">index automaton</a>, but a more widely name for is the Aho-Corasik automaton<sup class="footnote-reference"><a id="citeref-Aho1975" href="#footnote-Aho1975">[Aho1975]</a></sup>. This automaton provides an optimal complexity for string searching in a corpus, namely, once the automaton is built, the searching for the left hand sides of the rules (and hence rewriting) takes <code>Ω(length(w))</code> where <code>w</code> is the word being rewritten. Thus we can obtain rewrites in time independent of the size of the rewriting system.</p><p>To learn more about fast rewriting using the automaton see <a href="../rewriting/#Index-automaton-rewriting">Index automaton rewriting</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.KBIndex" href="#KnuthBendix.KBIndex"><code>KnuthBendix.KBIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KBIndex &lt;: KBS2Alg &lt;: CompletionAlgorithm</code></pre><p>The Knuth-Bendix completion algorithm that (if successful) yields the reduced, confluent rewriting system generated by rules of <code>rws</code>.</p><p><code>KBIndex</code> uses index automaton to perform rewrites, and delays the incorporation of newly found rules by maintaining a stack of them of size controlled by <code>reduce_delay</code> of the <code>Settings</code> passed along to <code>knuthbendix</code> call.</p><p>Additionally confluence checks by backtrack search on the index automaton are performed after periods when no new rules were discovered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/c12c1346cfbc7e580d5db8447588c7b2872e7369/src/knuthbendix_idxA.jl#L3-L15">source</a></section></article><p>You can run it on a <code>rws</code> by calling</p><pre><code class="language-julia hljs">knuthbendix(KnuthBendix.Settings(KnuthBendix.KBIndex()), rws)</code></pre><p>By default the size of the stack is <code>100</code> rules and  the algorithm terminates early after <code>10_000</code> of rewriting rules have been found. To control this behaviour <a href="../KB_implementations/#KnuthBendix.Settings"><code>Settings</code></a> struct has many knobs and whistles.</p><div class="admonition is-success" id="Performance-633a7ea98c7dd944"><header class="admonition-header">Performance<a class="admonition-anchor" href="#Performance-633a7ea98c7dd944" title="Permalink"></a></header><div class="admonition-body"><p>The 8th quotient of (2,3,7) triangle group from <a href="../knuthbendix2/#Using-a-stack">Knuth-Bendix completion using a stack</a> poses no challenges to <code>KBIndex</code> which solves it in a fraction of second. The performance bottleneck for larger examples is the incorporation of the stack of newly found rules into the rewriting system, while maintaining its reducedness (the construction of the index automaton, but more importantly, the confluence check require a reduced rewriting system).</p></div></div><hr/><p>Keeping the construction of the automaton as a black box, below is a julia-flavoured pseudocode describing the completion procedure.</p><pre><code class="language-julia hljs">function knuthbendix!(settings::Settings{KBIndex}, rws::RewritingSystem)
    stack = Vector{Tuple{Word,Word}}()
    rws = reduce!(rws) # this is assumed by IndexAutomaton!
    idxA = Automata.IndexAutomaton(rws)

    # ... initialize more temporary structures here
    for ri in rules(rws)
        for rj in rules(rws)
            find_critical_pairs!(stack, idxA, ri, rj, ...)
            ri === rj &amp;&amp; break
            find_critical_pairs!(stack, idxA, rj, ri, ...)
        end
        if lenght(stack) &gt; settings.reduce_delay || ri == last(rules(rws))
            # reduce the rws and then rebuild idxA
            rws, ... = reduce!(KBPrefix(), rws, stack)
            idxA, ... = Automata.rebuild!(idxA, rws)
        end

        if time_to_check_confluence(...)
            rws, ... = reduce!(KBPrefix(), rws, stack)
            idxA, ... = Automata.rebuild!(idxA, rws)
            stack = check_confluence!(stack, rws, idxA)
            if isempty(stack)
                return rws
            end
        end
    end
    return rws
end</code></pre><p>The main difference in the procedure is that instead immediately forcing reducedness with every discovered rule we delay this check until <code>stack</code> is sufficiently large. Only then</p><ol><li>we invoke <a href="../knuthbendix1/#KnuthBendix.reduce!-Tuple{KnuthBendix.KBPlain, RewritingSystem}"><code>reduce!</code></a> which<ul><li>constructs <a href="../prefix_automaton/#KnuthBendix.Automata.PrefixAutomaton"><code>PrefixAutomaton</code></a> from rules in <code>rws</code> and the <code>stack</code>.</li><li>reduces the automaton (with complexity <code>Ω(k²)</code>, where <code>k</code> is the number of rules in <code>rws</code>)</li><li>updates rules of <code>rws</code></li></ul></li><li>we re-sync the index automaton <code>idxA</code> with <code>rws</code>.</li></ol><p>This allows to amortize the time needed for reduction of <code>rws</code> (dominating!) and the construction of <code>idxA</code> (rather cheap, in comparison) across many different pairs of rules <code>(ri, rj)</code>.</p><h2 id="Backtrack-search-and-the-test-for-(local)-confluence"><a class="docs-heading-anchor" href="#Backtrack-search-and-the-test-for-(local)-confluence">Backtrack search and the test for (local) confluence</a><a id="Backtrack-search-and-the-test-for-(local)-confluence-1"></a><a class="docs-heading-anchor-permalink" href="#Backtrack-search-and-the-test-for-(local)-confluence" title="Permalink"></a></h2><p>Another very important feature of <a href="../index_automaton/#KnuthBendix.Automata.IndexAutomaton"><code>IndexAutomaton</code></a> is that it allows to test cheaply for confluence. Naively we need to check all pairs of rules for their suffix-prefix intersections and resolve the potentially critical pairs. However if we have an <code>idxA::IndexAutomaton</code> at our disposal checking for confluence becomes much easier: given a rule <code>lhs → rhs</code> from our rewriting system we need to see how can we extend <code>lhs[2:end]</code> to a word <code>w</code> which ends with the left-hand-side <code>lhs&#39;</code> of some other rule.</p><p>Here we don&#39;t need to search for all possible completions, since if <code>w</code> can be written as <code>w = lhs[2:end]*X*lhs&#39;</code>, then it satisfies local confluence w.r.t. the rewrites with the given rules trivially. If you think about index automaton as a tree with some (a plenty of) additional &quot;shortcut&quot; edges, then the answer is right in front of you: for every <code>lhs</code> we need to perform a single <strong>backtrack</strong> search on <code>idxA</code>. The search starts at the last state of <code>trace(idxA, lhs[2:end])</code>. We then backtrack</p><ul><li>when the depth of search becomes too large i.e. equal to <code>lenght(lhs[2:end])</code>, or</li><li>when the edge lead us to a vertex closer to the origin than we were (i.e. we took a shortcut).</li></ul><p>This mechanism is implemented by <a href="../backtrack/#KnuthBendix.Automata.ConfluenceOracle"><code>Automata.ConfluenceOracle</code></a>, see <a href="../backtrack/#Backtrack-searches">Backtrack searches</a>.</p><hr/><p>With this, instead of examining <code>k²</code> pairs for all possible suffix-prefix intersections it is enouth to perform <code>k</code> backtrack searches (where <code>k</code> is the number of rules of our <code>rws</code>). In pseudocode</p><pre><code class="language-julia hljs">function check_confluence(rws::RewritingSystem, idxA::IndexAutomaton)
    stack = Vector{Tupe{Word,Word}}()
    backtrack = Automata.BacktrackSearch(idxA, Automata.ConfluenceOracle())

    for ri in rules(rws)
        stack = find_critical_pairs!(stack, backtrack, ri, ...)
        isempty(stack) || break
        # i.e. we found some honest failures to local confluence
    end
    return stack
end</code></pre><p>If you inspect the actual code, you will be surprised how close it is to the listing above.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.find_critical_pairs!-Tuple{Any, KnuthBendix.Automata.BacktrackSearch, KnuthBendix.Rule, KnuthBendix.Workspace}" href="#KnuthBendix.find_critical_pairs!-Tuple{Any, KnuthBendix.Automata.BacktrackSearch, KnuthBendix.Rule, KnuthBendix.Workspace}"><code>KnuthBendix.find_critical_pairs!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_critical_pairs!(stack, bts, rule, work)</code></pre><p>Find critical pairs by completing lhs of <code>rule</code> by backtrack search on index automaton.</p><p>If <code>rule</code> can be written as <code>P → Q</code> this function performs a backtrack search on <code>bts.automaton</code> to find possible completions of <code>P[2:end]</code> to a word which ends with <code>P&#39;</code> where <code>P&#39; → Q&#39;</code> is another rule. The search backtracks when its depth is greater than or equal to the length of <code>P&#39;</code> to make sure that <code>P</code> and <code>P&#39;</code> share an overlap (i.e. a nonempty suffix of <code>P</code> is a prefix of <code>P&#39;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/c12c1346cfbc7e580d5db8447588c7b2872e7369/src/confluence_check.jl#L1-L11">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Sims1994"><a class="tag is-link" href="#citeref-Sims1994">Sims1994</a>Charles C. Sims <em>Computation with finitely presented groups</em>,          Cambridge University Press, 1994.</li><li class="footnote" id="footnote-Aho1975"><a class="tag is-link" href="#citeref-Aho1975">Aho1975</a>Alfred V. Aho and Margaret J. Corasick <em>Efficient string matching: an aid to bibliographic search</em> Commun. ACM 18, 6 (June 1975), 333–340. <a href="https://doi.org/10.1145/360825.360855">doi:10.1145/360825.360855</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../knuthbendix2/">« Using a stack</a><a class="docs-footer-nextpage" href="../knuthbendix_pfxA/">Using prefix automaton »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 3 September 2025 10:14">Wednesday 3 September 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

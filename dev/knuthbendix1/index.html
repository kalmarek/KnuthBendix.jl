<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Naive · KnuthBendix.jl</title><meta name="title" content="Naive · KnuthBendix.jl"/><meta property="og:title" content="Naive · KnuthBendix.jl"/><meta property="twitter:title" content="Naive · KnuthBendix.jl"/><meta name="description" content="Documentation for KnuthBendix.jl."/><meta property="og:description" content="Documentation for KnuthBendix.jl."/><meta property="twitter:description" content="Documentation for KnuthBendix.jl."/><meta property="og:url" content="https://kalmarek.github.io/KnuthBendix.jl/knuthbendix1/"/><meta property="twitter:url" content="https://kalmarek.github.io/KnuthBendix.jl/knuthbendix1/"/><link rel="canonical" href="https://kalmarek.github.io/KnuthBendix.jl/knuthbendix1/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KnuthBendix.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory/">Monoids and the word problem</a></li><li><a class="tocitem" href="../knuthbendix_completion/">Confluence and the Knuth-Bendix completion</a></li></ul></li><li><span class="tocitem">Words and Alphabets</span><ul><li><a class="tocitem" href="../words/">Words</a></li><li><a class="tocitem" href="../alphabets/">Alphabets</a></li><li><a class="tocitem" href="../orders/">Orders</a></li></ul></li><li><span class="tocitem">Rewriting</span><ul><li><a class="tocitem" href="../rewriting/">On rewriting</a></li><li><a class="tocitem" href="../rewriting_system/">Rewriting System</a></li></ul></li><li><span class="tocitem">Knuth-Bendix completion</span><ul><li><a class="tocitem" href="../KB_implementations/">Implementations of Knuth-Bendix completion</a></li><li class="is-active"><a class="tocitem" href>Naive</a><ul class="internal"><li><a class="tocitem" href="#Internal-functions"><span>Internal functions</span></a></li><li><a class="tocitem" href="#Example-from-theoretical-section"><span>Example from theoretical section</span></a></li></ul></li><li><a class="tocitem" href="../knuthbendix2/">Using a stack</a></li><li><a class="tocitem" href="../knuthbendix_idxA/">Using index automaton</a></li><li><a class="tocitem" href="../knuthbendix_pfxA/">Using prefix automaton</a></li></ul></li><li><span class="tocitem">Automata</span><ul><li><a class="tocitem" href="../automata/">Interface</a></li><li><a class="tocitem" href="../backtrack/">Backtrack searches</a></li><li><a class="tocitem" href="../index_automaton/">Index Automaton</a></li><li><a class="tocitem" href="../prefix_automaton/">Prefix Automaton</a></li></ul></li><li><a class="tocitem" href="../parsing_kbmag/">Parsing <code>kbmag</code> input files</a></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../nc_groebner/">Non-commutative Gröbner bases</a></li><li><a class="tocitem" href="../builtin_examples/">Example rewriting systems</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Knuth-Bendix completion</a></li><li class="is-active"><a href>Naive</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Naive</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kalmarek/KnuthBendix.jl/blob/master/docs/src/knuthbendix1.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Naive"><a class="docs-heading-anchor" href="#Naive">Naive</a><a id="Naive-1"></a><a class="docs-heading-anchor-permalink" href="#Naive" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.KBPlain" href="#KnuthBendix.KBPlain"><code>KnuthBendix.KBPlain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KBPlain &lt;: CompletionAlgorithm</code></pre><p>Run the Knuth-Bendix procedure that (if successful) yields the reduced, confluent rewriting system generated by rules of <code>rws</code>.</p><p>This is a simplistic algorithm for educational purposes only. It follows closely <code>KBS_1</code> procedure as described in <strong>Section 2.5</strong><sup class="footnote-reference"><a id="citeref-Sims1994" href="#footnote-Sims1994">[Sims1994]</a></sup>, p. 68.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Forced termination takes place after the number of rules stored in the <code>RewritingSystem</code> exceeds <code>max_rules</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/4e9da503c68c6f1375d7f7e2ae821e37f3d75f4d/src/knuthbendix1.jl#L1-L15">source</a></section></article><p>This version is a simplistic implementation of the completion that is terrible to run and great for understanding the general idea. It can be used on a <code>rws</code> by calling</p><pre><code class="language-julia hljs">knuthbendix(KnuthBendix.Settings(KnuthBendix.KBPlain()), rws)</code></pre><p>By default the algorithm breaks after <code>100</code> of rewriting rules has been found and prints its progress with much verbosity. To control this behaviour <a href="../KB_implementations/#KnuthBendix.Settings"><code>Settings</code></a> struct has many knobs and whistles.</p><hr/><p>Below is a julia-flavoured pseudocode describing the completion procedure.</p><pre><code class="language-julia hljs">function knuthbendix1(rws::RewritingSystem; kwargs...)
    for ri in rules(rws)
        for rj in rules(rws)
            forceconfluence!(rws, ri, rj)
            ri == rj &amp;&amp; break
            forceconfluence!(rws, rj, ri)
        end
        # Maybe some checks here, etc.
    end
    return rws
end</code></pre><p>Here <a href="#KnuthBendix.forceconfluence!-Tuple{RewritingSystem, KnuthBendix.Rule, KnuthBendix.Rule}"><code>forceconfluence!</code></a> finds all potential failures to local confluence in <code>rws</code> that arise as intersection of rules <code>ri</code> and <code>rj</code>, and <a href="#KnuthBendix.deriverule!-Tuple{RewritingSystem, KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord}"><code>deriverule!</code></a> resolves them. This means that all suffix-prefix words are identified (see <a href="../knuthbendix_completion/#Local-confluence-and-suffix-prefix-words">Local confluence and suffix-prefix words</a>) and the appropriate rules to resolve the failures in rewriting are <strong>pushed</strong> to <code>rws</code>. This extends<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> the iteration over <code>rules(rws)</code> and the outer loop becomes longer.</p><p>An important feature is that while the outer loop (<code>for ri in rules(rws)</code>) is potentially infinite, the inner one (<code>for rj in rules(rws)</code>) is always broken after a finite number of steps. We therefore traverse (potentially) doubly infinite iteration space in finite chunks which guarantees that each pair of rules will be considered <strong>after a finite amount of time</strong>. Completion even for very simple rewriting systems may fail if this condition is not observed.</p><p>As a side-effect we may choose to run some checks etc. after the inner loop is and we could e.g. decide to quit early (if things go out of hand) or do something else.</p><h2 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.forceconfluence!-Tuple{RewritingSystem, KnuthBendix.Rule, KnuthBendix.Rule}" href="#KnuthBendix.forceconfluence!-Tuple{RewritingSystem, KnuthBendix.Rule, KnuthBendix.Rule}"><code>KnuthBendix.forceconfluence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">forceconfluence!(rws::AbstractRewritingSystem, r₁, r₂)</code></pre><p>Examine overlaps of left hand sides of rules <code>r₁</code> and <code>r₂</code> to find (potential) failures to local confluence. New rules are added to assure local confluence if necessary.</p><p>Suppose that <code>r₁ = (lhs₁ → rhs₂)</code> and <code>r₂ = (lhs₂ → rhs₂)</code>. This function tries to write <code>lhs₁ = a·b</code> and <code>lhs₂ = b·c</code> so that word <code>a·b·c</code> can be rewritten in two potentially different ways:</p><blockquote><pre><code class="nohighlight hljs">       a·b·c
       /   \
      /     \
rhs₁·c    a·rhs₂</code></pre></blockquote><p>thus a (potentially) critical pair <code>(rhs₁·c, a·rhs₂)</code> needs to be resolved in the rewriting system.</p><p>It is not assumed that <code>rws</code> is reduced, and therefore also the case when <code>lhs₁ = a·lhs₂·c</code> with non-trivial <code>c</code> is examined.</p><p>See procedure <code>OVERLAP_1</code> in <sup class="footnote-reference"><a id="citeref-Sims1994" href="#footnote-Sims1994">[Sims1994]</a></sup>, p. 69.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/4e9da503c68c6f1375d7f7e2ae821e37f3d75f4d/src/knuthbendix1.jl#L64-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.deriverule!-Tuple{RewritingSystem, KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord}" href="#KnuthBendix.deriverule!-Tuple{RewritingSystem, KnuthBendix.Words.AbstractWord, KnuthBendix.Words.AbstractWord}"><code>KnuthBendix.deriverule!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deriverule!(rws::AbstractRewritingSystem, u::AbstractWord, v::AbstractWord)</code></pre><p>Given a critical pair <code>(u, v)</code> with respect to <code>rws</code> adds a rule to <code>rws</code> (if necessary) that resolves the pair, i.e. makes <code>rws</code> locally confluent with respect to <code>(u,v)</code>. See <sup class="footnote-reference"><a id="citeref-Sims1994" href="#footnote-Sims1994">[Sims1994]</a></sup>, p. 69.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/4e9da503c68c6f1375d7f7e2ae821e37f3d75f4d/src/knuthbendix1.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.reduce!-Tuple{KnuthBendix.KBPlain, RewritingSystem}" href="#KnuthBendix.reduce!-Tuple{KnuthBendix.KBPlain, RewritingSystem}"><code>KnuthBendix.reduce!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce!(::KBPlain, rws::RewritingSystem)</code></pre><p>Bring <code>rws</code> to its reduced form using the naive algorithm.</p><p>The returned system consists of rules <code>p → rewrite(p, rws)</code> for <code>p</code> in <a href="#KnuthBendix.irreducible_subsystem"><code>irreducible_subsystem(rws)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/4e9da503c68c6f1375d7f7e2ae821e37f3d75f4d/src/knuthbendix1.jl#L167-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KnuthBendix.irreducible_subsystem" href="#KnuthBendix.irreducible_subsystem"><code>KnuthBendix.irreducible_subsystem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">irreducible_subsystem(rws::AbstractRewritingSystem)</code></pre><p>Return an array of left sides of rules from rewriting system of which all the proper subwords are irreducible with respect to this rewriting system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/KnuthBendix.jl/blob/4e9da503c68c6f1375d7f7e2ae821e37f3d75f4d/src/knuthbendix1.jl#L198-L202">source</a></section></article><h2 id="Example-from-theoretical-section"><a class="docs-heading-anchor" href="#Example-from-theoretical-section">Example from theoretical section</a><a id="Example-from-theoretical-section-1"></a><a class="docs-heading-anchor-permalink" href="#Example-from-theoretical-section" title="Permalink"></a></h2><p>To reproduce the computations of the <a href="../knuthbendix_completion/#Knuth-Bendix-completion-an-example">Example</a> one could call <code>knuthbendix(KnuthBendix.KBPlain(), rws)</code> which prints step-by-step information:</p><pre><code class="language-julia-repl hljs">julia&gt; alph = Alphabet([:a,:A,:b],[2,1,0])
Alphabet of Symbol
  1. a    (inverse of: A)
  2. A    (inverse of: a)
  3. b

julia&gt; a,A,b = [Word([i]) for i in 1:length(alph)]
3-element Vector{Word{UInt16}}:
 Word{UInt16}: 1
 Word{UInt16}: 2
 Word{UInt16}: 3

julia&gt; relations = [(b^3, one(b)), (a*b, b*a)]
2-element Vector{Tuple{Word{UInt16}, Word{UInt16}}}:
 (3·3·3, (id))
 (1·3, 3·1)

julia&gt; rws = RewritingSystem(relations, LenLex(alph))
rewriting system with 4 active rules.
rewriting ordering: LenLex: a &lt; A &lt; b
┌──────┬──────────────────────────────────┬──────────────────────────────────┐
│ Rule │                              lhs │ rhs                              │
├──────┼──────────────────────────────────┼──────────────────────────────────┤
│    1 │                              a*A │ (id)                             │
│    2 │                              A*a │ (id)                             │
│    3 │                              b^3 │ (id)                             │
│    4 │                              b*a │ a*b                              │
└──────┴──────────────────────────────────┴──────────────────────────────────┘

julia&gt; knuthbendix(KnuthBendix.Settings(KnuthBendix.KBPlain()), rws)
┌ Warning: KBPlain is a simplistic completion algorithm for educational purposes only.
└ @ KnuthBendix ~/.julia/dev/KnuthBendix/src/knuthbendix1.jl:138
[ Info: considering (1, 1) for critical pairs
[ Info: considering (2, 1) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (2·1 ⇒ (id), 1·2 ⇒ (id))
│   (a, b, c) = (2, 1, 2)
└   pair = (2, 2)
[ Info: pair does not fail local confluence, both sides rewrite to 2
[ Info: considering (1, 2) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (1·2 ⇒ (id), 2·1 ⇒ (id))
│   (a, b, c) = (1, 2, 1)
└   pair = (1, 1)
[ Info: pair does not fail local confluence, both sides rewrite to 1
[ Info: considering (2, 2) for critical pairs
[ Info: considering (3, 1) for critical pairs
[ Info: considering (1, 3) for critical pairs
[ Info: considering (3, 2) for critical pairs
[ Info: considering (2, 3) for critical pairs
[ Info: considering (3, 3) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (3·3·3 ⇒ (id), 3·3·3 ⇒ (id))
│   (a, b, c) = (3·3, 3, 3·3)
└   pair = (3·3, 3·3)
[ Info: pair does not fail local confluence, both sides rewrite to 3·3
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (3·3·3 ⇒ (id), 3·3·3 ⇒ (id))
│   (a, b, c) = (3, 3·3, 3)
└   pair = (3, 3)
[ Info: pair does not fail local confluence, both sides rewrite to 3
[ Info: considering (4, 1) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (3·1 ⇒ 1·3, 1·2 ⇒ (id))
│   (a, b, c) = (3, 1, 2)
└   pair = (1·3·2, 3)
[ Info: pair fails local confluence, rewrites to 1·3·2 ≠ 3
[ Info: adding rule [ 5. a*b*A	 → 	b ] to rws
[ Info: considering (1, 4) for critical pairs
[ Info: considering (4, 2) for critical pairs
[ Info: considering (2, 4) for critical pairs
[ Info: considering (4, 3) for critical pairs
[ Info: considering (3, 4) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (3·3·3 ⇒ (id), 3·1 ⇒ 1·3)
│   (a, b, c) = (3·3, 3, 1)
└   pair = (1, 3·3·1·3)
[ Info: pair does not fail local confluence, both sides rewrite to 1
[ Info: considering (4, 4) for critical pairs
[ Info: considering (5, 1) for critical pairs
[ Info: considering (1, 5) for critical pairs
[ Info: considering (5, 2) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (1·3·2 ⇒ 3, 2·1 ⇒ (id))
│   (a, b, c) = (1·3, 2, 1)
└   pair = (3·1, 1·3)
[ Info: pair does not fail local confluence, both sides rewrite to 1·3
[ Info: considering (2, 5) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (2·1 ⇒ (id), 1·3·2 ⇒ 3)
│   (a, b, c) = (2, 1, 3·2)
└   pair = (3·2, 2·3)
[ Info: pair fails local confluence, rewrites to 3·2 ≠ 2·3
[ Info: adding rule [ 6. b*A	 → 	A*b ] to rws
[ Info: considering (5, 3) for critical pairs
[ Info: considering (3, 5) for critical pairs
[ Info: considering (5, 4) for critical pairs
[ Info: considering (4, 5) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (3·1 ⇒ 1·3, 1·3·2 ⇒ 3)
│   (a, b, c) = (3, 1, 3·2)
└   pair = (1·3·3·2, 3·3)
[ Info: pair does not fail local confluence, both sides rewrite to 3·3
[ Info: considering (5, 5) for critical pairs
[ Info: considering (6, 1) for critical pairs
[ Info: considering (1, 6) for critical pairs
[ Info: considering (6, 2) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (3·2 ⇒ 2·3, 2·1 ⇒ (id))
│   (a, b, c) = (3, 2, 1)
└   pair = (2·3·1, 3)
[ Info: pair does not fail local confluence, both sides rewrite to 3
[ Info: considering (2, 6) for critical pairs
[ Info: considering (6, 3) for critical pairs
[ Info: considering (3, 6) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (3·3·3 ⇒ (id), 3·2 ⇒ 2·3)
│   (a, b, c) = (3·3, 3, 2)
└   pair = (2, 3·3·2·3)
[ Info: pair does not fail local confluence, both sides rewrite to 2
[ Info: considering (6, 4) for critical pairs
[ Info: considering (4, 6) for critical pairs
[ Info: considering (6, 5) for critical pairs
[ Info: considering (5, 6) for critical pairs
┌ Info: lhs₁ suffix-prefix lhs₂:
│   rules = (1·3·2 ⇒ 3, 3·2 ⇒ 2·3)
│   (a, b, c) = (1, 3·2, (id))
└   pair = (3, 1·2·3)
[ Info: pair does not fail local confluence, both sides rewrite to 3
[ Info: considering (6, 6) for critical pairs
reduced, confluent rewriting system with 5 active rules.
rewriting ordering: LenLex: a &lt; A &lt; b
┌──────┬──────────────────────────────────┬──────────────────────────────────┐
│ Rule │                              lhs │ rhs                              │
├──────┼──────────────────────────────────┼──────────────────────────────────┤
│    1 │                              a*A │ (id)                             │
│    2 │                              A*a │ (id)                             │
│    3 │                              b*a │ a*b                              │
│    4 │                              b*A │ A*b                              │
│    5 │                              b^3 │ (id)                             │
└──────┴──────────────────────────────────┴──────────────────────────────────┘
</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Sims1994"><a class="tag is-link" href="#citeref-Sims1994">Sims1994</a>Charles C. Sims <em>Computation with finitely presented groups</em>,          Cambridge University Press, 1994.</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>If you don&#39;t like changing the structure while iterating over it you are   not alone, but sometimes it is the easiest things to do.</li><li class="footnote" id="footnote-Sims1994"><a class="tag is-link" href="#citeref-Sims1994">Sims1994</a>Charles C. Sims <em>Computation with finitely presented groups</em>,          Cambridge University Press, 1994.</li><li class="footnote" id="footnote-Sims1994"><a class="tag is-link" href="#citeref-Sims1994">Sims1994</a>Charles C. Sims <em>Computation with finitely presented groups</em>,          Cambridge University Press, 1994.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../KB_implementations/">« Implementations of Knuth-Bendix completion</a><a class="docs-footer-nextpage" href="../knuthbendix2/">Using a stack »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 20 November 2024 18:22">Wednesday 20 November 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

## KBS using index automata for rewriting

"""
    KBIndex <: KBS2Alg <: CompletionAlgorithm
The Knuth-Bendix completion algorithm that (if successful) yields the reduced,
confluent rewriting system generated by rules of `rws`.

`KBIndex` uses index automaton to perform rewrites, and delays
the incorporation of newly found rules by maintaining a stack of
them of size controlled by `reduce_delay` of the `Settings` passed along to
`knuthbendix` call.

Additionally confluence checks by backtrack search on the index automaton
are performed after periods when no new rules were discovered.
"""
struct KBIndex <: KBS2Alg end

function Settings(alg::KBIndex; kwargs...)
    return __Settings(
        alg;
        max_rules = 10_000,
        reduce_delay = 200,
        confluence_delay = 500,
        kwargs...,
    )
end

function time_to_rebuild(settings::Settings, ::AbstractRewritingSystem, stack)
    ss = settings.reduce_delay
    return ss <= 0 || length(stack) > ss
end

function knuthbendix!(settings::Settings{KBIndex}, rws::AbstractRewritingSystem)
    if !isreduced(rws)
        rws = reduce!(settings.algorithm, rws)
    end
    # rws is reduced now so we can create its index
    idxA = IndexAutomaton(rws)
    work = Workspace(idxA, settings)

    rws, idxA, work = knuthbendix!(rws, idxA, work)
    if work.dropped_rules > 0
        __kb__readd_defining_rules!(rws, settings)
    end
    return rws
end

function knuthbendix!(
    rws::AbstractRewritingSystem{W},
    idxA::IndexAutomaton,
    work::Workspace{KBIndex},
) where {W}
    @assert isreduced(rws)
    stack = Vector{Tuple{W,W}}()
    rwrules = __rawrules(rws)
    settings = work.settings
    pfxA = PrefixAutomaton(rws)
    work_pfxA = Workspace(pfxA, Settings(KBPrefix(), settings))

    i = firstindex(rwrules)
    while i ≤ lastindex(rwrules)
        if time_to_check_confluence(rws, work)
            if !isempty(stack)
                Automata.rebuild!(pfxA)
                reduced, (i, _) = reduce!(pfxA, work_pfxA, stack, i, 0)
                rws.reduced = reduced
                @assert isreduced(rws)
                idxA = Automata.rebuild!(idxA, rws)
            end

            @assert isempty(stack)
            stack, i = __kb__check_confluence(rws, idxA, stack, i, work)
            if isempty(stack)
                merge!(work, work_pfxA)
                return rws, idxA, work
            end
        end

        ri = rwrules[i]
        j = firstindex(rwrules)
        new_rules = false
        while j ≤ i
            rj = rwrules[j]
            l = length(stack)
            stack = find_critical_pairs!(stack, idxA, ri, rj, work)
            if ri !== rj
                stack = find_critical_pairs!(stack, idxA, rj, ri, work)
            end
            new_rules |= length(stack) > l

            if time_to_rebuild(settings, rws, stack)
                Automata.rebuild!(pfxA)
                reduced, (i, j) = reduce!(pfxA, work_pfxA, stack, i, j)
                rws.reduced = reduced
                @assert isreduced(rws)
                idxA = Automata.rebuild!(idxA, rws)
                @assert isempty(stack)
            end

            if are_we_stopping(settings, rws)
                Automata.rebuild!(pfxA)
                reduced, _ = reduce!(pfxA, work_pfxA, stack)
                rws.reduced = reduced
                @assert isreduced(rws)
                idxA = Automata.rebuild!(idxA, rws)
                merge!(work, work_pfxA)
                return rws, idxA, work
            end

            if settings.verbosity == 1 && i ≠ lastindex(rwrules)
                total = nrules(rws)
                stack_size = length(stack)
                settings.update_progress(total, i, stack_size)
            end
            j += 1
            work.confluence_timer = !new_rules ? work.confluence_timer + 1 : 0
        end

        if i == lastindex(rwrules)
            if settings.verbosity == 2
                @info "reached end of rwrules with $(length(stack)) rules on stack"
            end
            # Automata.rebuild!(pfxA)
            # reduced, (i, _) = reduce!(pfxA, work_pfxA, stack, i, 0)
            # rws.reduced = reduced
            Automata.rebuild!(pfxA)
            reduced, (i, _) = reduce!(pfxA, work_pfxA, stack, i, 0)
            rws.reduced = reduced
            @assert isreduced(rws)
            idxA = Automata.rebuild!(idxA, rws)
        end
        i += 1
    end

    merge!(work, work_pfxA)
    # rws is reduced during the whole procedure
    return rws, idxA, work
end

function __kb__check_confluence(
    rws::AbstractRewritingSystem,
    idxA::IndexAutomaton,
    stack::AbstractVector,
    i::Integer,
    work::Workspace,
)
    if work.settings.verbosity == 2
        @info "no new rules found checking $(work.settings.confluence_delay) pairs, attempting a confluence check at" i,
        rws.rwrules[i]
    end
    @assert isempty(stack)
    stack, i_after = check_confluence!(stack, rws, idxA, work)
    success = isempty(stack)
    if work.settings.verbosity == 2
        success && @info "stack empty, found confluent rws!"
        l = length(stack)
        success ||
            @info "confluence check failed: found $(l) new rule$(l==1 ? "" : "s")"
    end
    return stack, max(i, i_after)
end

## KBS using index automata for rewriting

"""
    KBIndex <: KBS2Alg <: CompletionAlgorithm
The Knuth-Bendix completion algorithm that (if successful) yields the reduced,
confluent rewriting system generated by rules of `rws`.

`KBIndex` uses index automaton to perform rewrites, and delays
the incorporation of newly found rules by maintaining a stack of
them of size controlled by `stack_size` of the `Settings` passed along to
`knuthbendix` call.

Additionally confluence checks by backtrack search on the index automaton
are performed after periods when no new rules were discovered.
"""
struct KBIndex <: KBS2Alg end

Settings(::KBIndex) = Settings(; max_rules = 5_000, stack_size = 200)

function time_to_rebuild(::AbstractRewritingSystem, stack, settings::Settings)
    ss = settings.stack_size
    return ss <= 0 || length(stack) > ss
end

function remove_inactive!(rws::RewritingSystem, i::Integer, j::Integer)
    # compute the shifts for iteration indices
    lte_i = 0 # less than or equal to i
    lte_j = 0
    for (idx, r) in pairs(rws.rwrules)
        if !isactive(r)
            if idx ≤ i
                lte_i += 1
            end
            if idx ≤ j
                lte_j += 1
            end
        end
        idx ≥ max(i, j) && break
    end
    i -= lte_i
    j -= lte_j
    i = max(i, firstindex(rws.rwrules))
    j = max(j, firstindex(rws.rwrules))

    remove_inactive!(rws)
    return i, j
end

"""
    reduce!(::KBS2Alg, rws::RewritingSystem, stack, ...)
Append rules from `stack` to `rws` maintaining reducedness.

Assuming that `rws` is reduced merge `stack` of rules into `rws` using
[`deriverule!`](@ref deriverule!(::RewritingSystem, ::Any, ::Workspace)).
"""
function reduce!(
    ::KBS2Alg,
    rws::RewritingSystem,
    stack,
    i::Integer = 0,
    j::Integer = 0,
    work::Workspace = Workspace(rws),
)
    # we want shortest rules are at the top of the stack
    sort!(stack, by = length ∘ first, rev = true)
    # 1. adding/deactivating new rules to rws
    # Note: can't use index automaton, as we're modifying rws here
    deriverule!(rws, stack, work)
    @assert isempty(stack)

    i, j = remove_inactive!(rws, i, j)

    return rws, (i, j)
end

function knuthbendix!(
    method::KBIndex,
    rws::RewritingSystem{W},
    settings::Settings = Settings(),
) where {W}
    if !isreduced(rws)
        rws = reduce!(method, rws)
    end
    # rws is reduced now so we can create its index
    idxA = IndexAutomaton(rws)
    work = Workspace(idxA)
    stack = Vector{Tuple{W,W}}()

    i = firstindex(rws.rwrules)
    while i ≤ lastindex(rws.rwrules)
        if time_to_check_confluence(rws, work, settings)
            if settings.verbosity == 2
                @info "no new rules found for $(settings.confluence_delay) itrs, attempting a confluence check at" i,
                rws.rwrules[i]
            end
            if !isempty(stack)
                rws, (i, _) = reduce!(method, rws, stack, i, 0, work)
                idxA = Automata.rebuild!(idxA, rws)
            end
            @assert isempty(stack)
            stack, i_after = check_confluence!(stack, rws, idxA, work)
            isempty(stack) && return rws # yey, we're done!
            if settings.verbosity == 2
                l = length(stack)
                @info "confluence check failed: found $(l) new rule$(l==1 ? "" : "s")"
            end
            # @info (i, i_after)
            i = max(i, i_after)
            work.confluence_timer = 0
        end

        work.confluence_timer += 1
        ri = rws.rwrules[i]
        j = firstindex(rws.rwrules)
        while j ≤ i
            if are_we_stopping(rws, settings)
                return reduce!(method, rws, work)
            end

            # TODO: can we multithread this part?
            # Note:
            #   1. each thread needs its own stack, work;
            #   2. idxA stores path which makes rewriting with it thread unsafe

            rj = rws.rwrules[j]
            l = length(stack)
            stack = find_critical_pairs!(stack, idxA, ri, rj, work)
            if ri !== rj
                stack = find_critical_pairs!(stack, idxA, rj, ri, work)
            end

            if length(stack) - l > 0 && time_to_rebuild(rws, stack, settings)
                rws, (i, j) = reduce!(method, rws, stack, i, j, work)
                idxA = Automata.rebuild!(idxA, rws)
                @assert isempty(stack)
                # rws is reduced by now
            end
            if settings.verbosity == 1
                total = nrules(rws)
                stack_size = length(stack)
                settings.update_progress(total, i, stack_size)
            end
            j += 1
        end

        # we finished processing all rules but the stack is nonempty
        if i == lastindex(rws.rwrules) && !isempty(stack)
            if settings.verbosity == 2
                @info "reached end of rwrules with $(length(stack)) rules on stack"
            end
            rws, (i, _) = reduce!(method, rws, stack, i, 0, work)
            idxA = Automata.rebuild!(idxA, rws)
        end
        i += 1
    end
    return rws # so the rws is reduced here as well
end

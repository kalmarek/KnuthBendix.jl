## Naive, i.e. KBS2 implementation

abstract type KBS2AlgAbstract <: CompletionAlgorithm end
struct KBS2AlgPlain <: KBS2AlgAbstract end

@inline function _iscritical(
    u::AbstractWord,
    v::AbstractWord,
    rewriting,
    work::Workspace,
)
    a = rewrite!(work.iscritical_1p, u, rewriting)
    b = rewrite!(work.iscritical_2p, v, rewriting)
    return a ≠ b, (a, b)
end

"""
    find_critical_pairs!(stack, rws, r₁::Rule, r₂::Rule[, work=Workspace(rws))
Find critical pairs derived from suffix-prefix overlaps of lhses of `r₁` and `r₂`.

Such failures (i.e. failures to local confluence) arise as `W = ABC` where
`AB`, `BC` are the left-hand-sides of rules `r₁` and `r₂`, respectively.
It is assumed that all `A`, `B` and `C` are nonempty.
"""
function find_critical_pairs!(
    stack,
    rewriting,
    r₁::Rule,
    r₂::Rule,
    work::Workspace = Workspace(rewriting),
)
    lhs₁, rhs₁ = r₁
    lhs₂, rhs₂ = r₂
    m = min(length(lhs₁), length(lhs₂)) - 1
    W = word_type(rewriting)

    # TODO: cache suffix automaton for lhs₁ to run this in O(m) (currently: O(m²))
    for b in suffixes(lhs₁, 1:m)
        if isprefix(b, lhs₂)
            lb = length(b)
            @views rhs₁_c, a_rhs₂ = Words.store!(
                work.find_critical_p,
                (lhs₁[1:end-lb], rhs₂),
                (rhs₁, lhs₂[lb+1:end]),
            )
            critical, (P, Q) = _iscritical(a_rhs₂, rhs₁_c, rewriting, work)
            # memory of a and c is owned by work.find_critical_p
            # so we need to call constructors
            critical && push!(stack, (W(P, false), W(Q, false)))
            # balance!(stack, P, Q, rewriting)
        end
    end
    return stack
end

"""
    deriverule!(rws::RewritingSystem, stack[, work = Workspace(rws)])
Empty `stack` of (potentially) critical pairs by deriving and adding new rules
to `rws` resolving the pairs, i.e. maintains local confluence of `rws`.

This function may deactivate rules in `rws` if they are deemed redundant (e.g.
follow from the added new rules). See [Sims, p. 76].
"""
function deriverule!(
    rws::RewritingSystem{W},
    stack,
    work::Workspace = Workspace(rws),
) where {W}
    ord = ordering(rws)
    while !isempty(stack)
        u, v = pop!(stack)
        critical, (a, b) = _iscritical(u, v, rws, work)
        if critical
            simplify!(a, b, ord)
            new_rule = Rule{W}(W(a, false), W(b, false), ord)
            push!(rws, new_rule)
            deactivate_rules!(rws, stack, new_rule, work)
        end
    end
end

function deactivate_rules!(
    rws::RewritingSystem,
    stack,
    new_rule::Rule,
    work::Workspace = Workspace(rws),
)
    for rule in rules(rws)
        rule == new_rule && continue
        (lhs, rhs) = rule
        if occursin(first(new_rule), lhs)
            deactivate!(rule)
            push!(stack, (lhs, rhs))
        elseif occursin(first(new_rule), rhs)
            new_rhs = rewrite!(work.iscritical_1p, rhs, rws)
            Words.store!(rule, new_rhs)
        end
    end
end

"""
    forceconfluence!(rws::RewritingSystem, stack, r₁, r₂[, work = Workspace(rws)])
Examine overlaps of left hand sides of rules `r₁` and `r₂` to find (potential)
failures to local confluence. New rules are added to assure local confluence if
necessary.

This version assumes the reducedness of `rws` so that failures to local confluence
are of the form `a·b·c` with all `a`, `b`, `c` non trivial and `lhs₁ = a·b` and
`lhs₂ = b·c`.

This version uses `stack` to maintain the reducedness of `rws` and
`work::Workspace` to save allocations in the rewriting.

See procedure `OVERLAP_2` in [Sims, p. 77].
"""
function forceconfluence!(
    rws::RewritingSystem{W},
    stack,
    r₁,
    r₂,
    work::Workspace = Workspace(rws),
) where {W}
    stack = find_critical_pairs!(stack, rws, r₁, r₂, work)
    return deriverule!(rws, stack, work)
end

"""
    knuthbendix2(rws::RewritingSystem; max_rules::Integer=100)
Run the Knuth-Bendix procedure that (if successful) yields the reduced,
confluent rewriting system generated by rules of `rws`.

This implementation follows closely `KBS_2` procedure as described in

> Ch.C. Sims _Computation with finitely presented groups_
> [Section 2.6 The Knuth-Bendix procedure, p.76].

!!! warning
    Forced termination takes place after the number of **active** rules
    stored in the `RewritingSystem` reaches `max_rules`.
"""
function knuthbendix2(rws::RewritingSystem; max_rules = 100)
    return knuthbendix!(
        KBS2AlgPlain(),
        deepcopy(rws),
        Settings(; max_rules = max_rules),
    )
end

function knuthbendix!(
    method::KBS2AlgPlain,
    rws::RewritingSystem{W},
    settings::Settings = Settings(),
) where {W}
    work = Workspace(rws)
    stack = Vector{Tuple{W,W}}()
    rws = reduce!(method, rws, work) # we begin with a reduced system

    for (i, r₁) in enumerate(rules(rws))
        are_we_stopping(rws, settings) && break
        for r₂ in rules(rws)
            isactive(r₁) || break
            forceconfluence!(rws, stack, r₁, r₂, work)

            r₁ === r₂ && break
            isactive(r₁) || break
            isactive(r₂) || continue
            forceconfluence!(rws, stack, r₂, r₁, work)
        end

        if settings.verbosity > 0
            total = count(isactive, rws.rwrules)
            settings.update_progress(total, i)
        end
    end
    return rws # so the rws is reduced here as well
end

"""
    reduce!(::NaiveKBS2Alg, rws::RewritingSystem)
Bring `rws` to its reduced form using the stack-based algorithm.

A stack of active rules from `rws` is extracted, `rws` emptied and then the
stack is merged into `rws` using the [`deriverule!`](@ref
deriverule!(::RewritingSystem, ::Any, ::Workspace)).
"""
function reduce!(
    ::KBS2AlgAbstract,
    rws::RewritingSystem,
    work::Workspace = Workspace(rws);
    sort_rules = true,
)

    R = try
        remove_inactive!(rws)
        stack = [(first(r), last(r)) for r in rules(rws)]
        # we want shortest rules are at the top of the stack
        sort!(stack, by = length ∘ first, rev = true)

        R = empty(rws)
        deriverule!(R, stack, work)
        @assert isempty(stack)
        remove_inactive!(R)

        if sort_rules
            reverse!(R.rwrules)
            sort!(R.rwrules, by = length ∘ first)
        end
        R
    catch e
        if e isa InterruptException
            @warn """Received user interrupt while reducing a rewriting system.
            Returned rws may be not reduced"""
            return rws
        end
        rethrow(e)
    end

    resize!(rws.rwrules, nrules(R))
    copyto!(rws.rwrules, R.rwrules)

    return rws
end

"""
    reduce!(rws::RewritingSystem[, work=Workspace(rws); kwargs...])
Reduce the rewriting system in-place using the default algorithm

Currently the default algorithm is KBS2AlgPlain(), see
[`reduce!(::KBS2AlgPlain, ...)`](@ref
reduce!(::KBS2AlgPlain, ::RewritingSystem, work::Workspace)).
"""
function reduce!(
    rws::RewritingSystem,
    work::Workspace = Workspace(rws);
    kwargs...,
)
    return reduce!(KBS2AlgPlain(), rws, work; kwargs...)
end
